<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>partFcts.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#partFcts.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>partFcts.tcl</strong>
(<a href="partFcts.tcl-annot.html">annotations</a> | <a href="partFcts.tcl.txt">original source</a>)
<p>
<pre>
<font color="#208020"># partFcts.tcl --</font>
<font color="#208020">#</font>
<font color="#208020">#       This file implements the Tcl code for partition functions handling.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright (c) 1998-1999 Nicolas Decoster.</font>
<font color="#208020">#   Copyright (c) 1998-1999 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright (c) 1999-2007 Pierre Kestener.</font>
<font color="#208020">#   Copyright (c) 1999-2002 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#   Copyright (c) 2002-2003 Ecole Normale Superieure de Lyon, Lyon, France.</font>
<font color="#208020">#   Copyright (c) 2003-2007 CEA DSM/DAPNIA/SEDI, centre Saclay, France.</font>
<font color="#208020">#</font>
<font color="#208020">#</font>

<font color="#208020"># last modified by Pierre Kestener (2000/06/21).</font>
<font color="#208020"># modified by Pierre Kestener (between 2001/03/09 and 2001/03/20)</font>
<font color="#208020"># to include Tsallis entropies computation :</font>
<font color="#208020"># thd_tsallis, compute_tsallis, thdFit_tsallis ...</font>


package provide pf 0.0

namespace eval pf {
    variable pf
    variable currentId

    variable allowedMethodsArray 
    array set allowedMethodsArray {
	&#34;Gradient lines&#34;	2D
	&#34;Gradient max&#34;		2D
	&#34;Gradient max - tag&#34;	2D
	&#34;Gradient max - notag&#34;	2D
	&#34;Gradient max - theta&#34;	2D
	&#34;Mexican&#34;		2D
	&#34;gauss&#34;			1D
	&#34;d1 gauss&#34;		1D
	&#34;d2 gauss&#34;		1D
	&#34;d3 gauss&#34;		1D
	&#34;d4 gauss&#34;		1D
	&#34;morlet&#34;		1D
    }
}


<font color="#208020"># pf --</font>
<font color="#208020"># usage : pf args</font>
<font color="#208020">#</font>
<font color="#208020">#   Execute a script in the pf namespace.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   args - a list of arg.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Result of the execution.</font>

<strong><a name="pf_56">proc <a href="partFcts.tcl-annot.html#pf">pf</a></a></strong><a name="pf"></a> args {
    if {[llength $args] != 0} {
	set cmd [concat namespace inscope pf $args]
	set code [catch {eval $cmd} result]
	if {$code != 0} {
	    return -code error &#34;pf : $result&#34;
	} else {
	    return $result
	}
    }
}


<font color="#208020"># pf::create --</font>
<font color="#208020"># usage : pf::create</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a pf structure and init its parameter to non-sense values.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   none.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The pf id.</font>

<strong><a name="pf::create_80">proc <a href="partFcts.tcl-annot.html#pf::create">pf::create</a></a></strong><a name="pf::create"></a> {args} {
    <font color="#208020"># Get an id and create an array.</font>
    variable currentId

    variable pf
    if ![info exists pf(pfid)] {
	set pf(pfid) 0
    }
    set pfid [namespace current]::[incr pf(pfid)]
    variable $pfid
    upvar 0 $pfid state

    array set state {
	a_min		-1
	n_octave	0
	n_voice		0
	first_octave	-1
	last_octave	-1
	first_voice	-1
	last_voice	-1
	q_lst		{}
	n_study		0
	size		-1
	dimension	-1
	study_method	none
	comments	{no comment}
	qtsa_lst        {}
	qturb_lst       {0 1 2 3}
    }
    set state(baseSigName)	_pf$pf(pfid)

    set currentId $pfid

    return $pfid
}


<font color="#208020"># pf::destroy --</font>
<font color="#208020"># usage : pf::destroy pfId</font>
<font color="#208020">#</font>
<font color="#208020">#   End a pf and free all memory that can be freed.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId - the pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::destroy_128">proc <a href="partFcts.tcl-annot.html#pf::destroy">pf::destroy</a></a></strong><a name="pf::destroy"></a> {pfid} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    DeletePfSig $pfid
    unset state

    return
}


<font color="#208020"># pf::clear --</font>
<font color="#208020"># usage : pf::clear pfId</font>
<font color="#208020">#</font>
<font color="#208020">#   Re-init a pf and free all memory that can be freed.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId - the pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::clear_154">proc <a href="partFcts.tcl-annot.html#pf::clear">pf::clear</a></a></strong><a name="pf::clear"></a> {pfid} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }

    DeletePfSig $pfid

    variable $pfid
    upvar 0 $pfid state

    array set state {
	a_min		-1
	n_octave	0
	n_voice		0
	first_octave	-1
	last_octave	-1
	first_voice	-1
	last_voice	-1
	q_lst		{}
	n_study		0
	size		-1
	dimension	-1
	study_method	none
	comments	{no comment}
	qtsa_lst	{}
	qturb_lst       {}
    }

    set currentId $pfid

    return
}


<font color="#208020"># pf::DeletePfSig - PRIVATE</font>
<font color="#208020"># usage : DeletePfSig pfId</font>
<font color="#208020">#</font>
<font color="#208020">#   Delete all signals assoziated with a pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId - the pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::DeletePfSig_200">proc <a href="partFcts.tcl-annot.html#pf::DeletePfSig">pf::DeletePfSig</a></a></strong><a name="pf::DeletePfSig"></a> {pfid} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set base $state(baseSigName)

    <font color="#208020"># We delete all the signals that begin with the base name. It might be</font>
    <font color="#208020"># dangerous. Perhaps (in the future...) I will removes signals by their</font>
    <font color="#208020"># complete names.</font>
    catch {delete ${base}*}
}


<font color="#208020"># pf::help --</font>
<font color="#208020"># usage : pf::help [proc]</font>
<font color="#208020">#</font>
<font color="#208020">#   Get help on pf pakage.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [proc] - help on a proc.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Help message.</font>


<strong><a name="pf::help_229">proc <a href="partFcts.tcl-annot.html#pf::help">pf::help</a></a></strong><a name="pf::help"></a> args {
    if {[llength $args] == 0} {
	set resStr &#34;Pakage pf :

  This pakage handle partition functions. Use the \&#34;pf\&#34; command to execute
scripts (or commands) in the pf pakage. Each group of part functions (associated
to a \&#34;study\&#34;) is identified by a pf id. Most of the following commands need
this pf id as a first parameter. if you use the character \&#34;c\&#34; (for current)
instead of the pf id, the command takes the last pf id used.

List of internal commands :
  create
  destroy
  clear
  help
  swLoad
  swSave
  thd
  thd_tsallis
  disp
  disp2
  disphqa
  init
  compute
  save
  load
  localfit
  lfDisp
  localslope
  lsDisp
  Dh
  thdDisp
  taudDisp
  getParam
  setcomments
&#34;
    } else {
	global auto_index

	set cmdName [lindex $args 0]
	set code [catch &#34;set auto_index(::pf::$cmdName)&#34; result]
	if {$code != 0} {
	    return -code error &#34;no command \&#34;$cmdName\&#34; in pakage pf&#34;
	}
	set fileName [lindex $result 1]
	if {[string compare [lindex [file split $fileName] end] &#34;partFcts.tcl&#34;] != 0} {
	    return -code error &#34;no command \&#34;$cmdName\&#34; in pakage pf&#34;
	}

	<font color="#208020"># Set the default message.</font>
	set resStr &#34;Sorry, no help for `$cmdName'.&#34;

	set fileId [open $fileName r]

	while {[gets $fileId line] != -1} {
	    if {[string compare $line &#34;# pf::$cmdName --&#34;] == 0} {
		<font color="#208020"># header line of help comment is found.</font>
		unset resStr
		while {[gets $fileId line] != -1} {
		    if {[regexp {^# *} $line]} {
			<font color="#208020"># the line begins by &#34;#&#34; -&gt; it is a help comment line.</font>
			<font color="#208020"># Remove the leading &#34;#&#34; ...</font>
			regsub {^# } $line &#34;&#34; line
			regsub {^#} $line &#34;&#34; line
			<font color="#208020"># ... and add to result</font>
			if {[info exist resStr] == 1} {
			    set resStr [format &#34;%s\n%s&#34; $resStr &#34;$line&#34;]
			} else {
			    set resStr $line
			}
		    } else {
			<font color="#208020"># No more leading &#34;#&#34; -&gt; end of help comment.</font>
			break
		    }
		}
		if {[info exist resStr] != 1} {
		    <font color="#208020"># There was no line beginning with &#34;#&#34; after the</font>
		    <font color="#208020"># header line of the help comment.</font>
		    set resStr &#34;Sorry, no help for `$cmdName'.&#34;
		}		    
		<font color="#208020"># Exit the loop on file lines.</font>
		break
	    }
	}
	close $fileId

	set resStr [format &#34;%s\n\n(file : %s)&#34; $resStr $fileName]
    }

    return $resStr
}


<font color="#208020"># pf::CheckPfid - PRIVATE</font>
<font color="#208020"># usage : CheckPfid pfId</font>
<font color="#208020">#</font>
<font color="#208020">#   Check if a pf id is valid.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId - the pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   This proc returns the pf id if it is valid, 0 otherwise.</font>

<strong><a name="pf::CheckPfid_333">proc <a href="partFcts.tcl-annot.html#pf::CheckPfid">pf::CheckPfid</a></a></strong><a name="pf::CheckPfid"></a> {pfid} {
    <font color="#208020"># For now this proc only check the existence of pfid as an array. In the</font>
    <font color="#208020"># future we can imagine other checks.</font>

    variable currentId

    if {[string compare $pfid c] == 0} {
	return $currentId
    }

    if [array exists $pfid] {
	set currentId $pfid
	return $pfid
    } else {
	return 0
    }
}


<font color="#208020"># pf::StateCheck -- PRIVATE</font>
<font color="#208020"># usage : StateCheck pfId list</font>
<font color="#208020">#</font>
<font color="#208020">#   Check if a pf state is valid.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId - The pf id.</font>
<font color="#208020">#   list - List of the checks to do.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   This proc returns with error if the pf state is not valid.</font>

<strong><a name="pf::StateCheck_364">proc <a href="partFcts.tcl-annot.html#pf::StateCheck">pf::StateCheck</a></a></strong><a name="pf::StateCheck"></a> {pfid args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -dataExist {
		if {$state(n_study) &lt;= 0} {
		    return -code error &#34;no data&#34;
		}
		set args [lreplace $args 0 0]
	    }
	    -thdDone {
		set q [lindex $state(q_lst) 0]
		set qStr [<a name="get_q_str(1)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
		set sigName $state(baseSigName)_tau${qStr}
		if {[string compare [gettype $sigName] S]} {
		    return -code error &#34;Z, h and D are not computed (use command \&#34;thd\&#34;)&#34;
		}
		set args [lreplace $args 0 0]
	    }
	    -thdFitDone {
		set q [lindex $state(q_lst) 0]
		set qStr [<a name="get_q_str(2)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
		set sigName $state(baseSigName)_hq
		if {[string compare [gettype $sigName] S]} {
		    return -code error &#34;h(q) and D(q) are not computed (use command \&#34;thdFit\&#34;)&#34;
		}
		set args [lreplace $args 0 0]
	    }
	    -localfitDone {
		set name [lindex $args 1]
		if {[array get state localfit,$name,q_lst] == &#34;&#34;} {
		    return -code error &#34;no local fit done for $name (use command \&#34;localfit\&#34;)&#34;
		}
		set args [lreplace $args 0 1]
	    }
	    -localslopeDone {
		set name [lindex $args 1]
		set q [lindex $args 2]
		if {[array get state localslope,$name,q_lst] == &#34;&#34;} {
		    return -code error &#34;no local slope done for $name and q = $q (use command \&#34;localslope\&#34;)&#34;
		}
		set flag 0
		foreach val $state(localslope,$name,q_lst) {
		    if {$val == $q} {
			set flag 1
			break
		    }
		}
		if {$flag == 0} {
		    return -code error &#34;no local slope done for $name and q = $q (use command \&#34;localslope\&#34;)&#34;
		}
		set args [lreplace $args 0 2]
	    }
	    default {
		set args [lreplace $args 0 0]
	    }
	}
    }

    return
}


<font color="#208020"># pf::swLoad --</font>
<font color="#208020"># usage : pf::swLoad pfId string</font>
<font color="#208020">#</font>
<font color="#208020">#   Load signals that contains STq, logSTq and STqlogT from files in the old sw</font>
<font color="#208020"># partition function format.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   string - Base name of the sw files.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::swLoad_446">proc <a href="partFcts.tcl-annot.html#pf::swLoad">pf::swLoad</a></a></strong><a name="pf::swLoad"></a> {pfid fileName} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set base $state(baseSigName)

    if {$state(n_study) == 0} {
	<font color="#208020"># Create new values</font>
	
	<font color="#208020"># Read general file.</font>
	set file [open $fileName r]

	set state(n_octave) [lindex [gets $file] 1]
	set state(n_voice) [lindex [gets $file] 1]
	set state(study_method) [lindex [gets $file] 1]

	if {[string compare $state(study_method) &#34;Gauss_dx_dy&#34;] == 0} {
	    set state(study_method) &#34;Gradient lines&#34;
	}
	set state(a_min) [lindex [gets $file] 1]
	gets $file q
	while {$q != &#34;&#34;} {
	    lappend state(q_lst) $q
	    gets $file q
	}
	close $file

	foreach q $state(q_lst) {
	    set q_str [<a name="get_q_str(3)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	    <font color="#208020"># Read existing data.</font>
	    set STq_file	[open ${fileName}_Pq.$q_str r]
	    set logSTq_file	[open ${fileName}_logsP.$q_str r]
	    set STqlogT_file	[open ${fileName}_PqlogP.$q_str r]

	    catch {unset STq_lst}
	    catch {unset logSTq_lst}
	    catch {unset STqlogT_lst}
	    for {set o 0} {$o &lt; $state(n_octave)} {incr o} {
		for {set v 0} {$v &lt; $state(n_voice)} {incr v} {
		    lappend STq_lst	[gets $STq_file]
		    set val [gets $logSTq_file]
		    if {[string compare $val &#34;--.-00000e+01&#34;] == 0} {
			set val 0
		    }
		    lappend logSTq_lst $val
		    lappend STqlogT_lst	[gets $STqlogT_file]
		}
	    }

	    close $STq_file
	    close $logSTq_file
	    close $STqlogT_file

	    screate ${base}_STq_$q_str \
		    0 [expr 1.0/$state(n_voice)] $STq_lst
	    screate ${base}_logSTq_$q_str\
		    0 [expr 1.0/$state(n_voice)] $logSTq_lst
	    screate ${base}_STqlogT_$q_str \
		    0 [expr 1.0/$state(n_voice)] $STqlogT_lst
	}

	set state(first_octave)	0
	set state(last_octave)	[expr $state(n_octave)-1]
	set state(first_voice)	0
	set state(last_voice)	[expr $state(n_voice)-1]
	set state(n_study)	1
	set state(size)		-1
	set state(dimension)	2D
	set state(comments)	$fileName
    } else {
	return -code error &#34;can't add from a sw file&#34;
    }
}


<font color="#208020"># pf::swSave --</font>
<font color="#208020"># usage pf::swSave pfId str</font>
<font color="#208020">#</font>
<font color="#208020">#   Save the partition functions in the sw format.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   string - File name.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::swSave_538">proc <a href="partFcts.tcl-annot.html#pf::swSave">pf::swSave</a></a></strong><a name="pf::swSave"></a> {pfid name} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    <font color="#208020"># Create general file.</font>

    set file [open $name w]
    puts $file &#34;noct $state(n_octave)&#34;
    puts $file &#34;nvoice $state(n_voice)&#34;
    puts $file &#34;wavelet $state(study_method)&#34;
    puts $file &#34;amin $state(a_min)&#34;
    foreach q $state(q_lst) {
	puts $file $q
    }
    close $file

    <font color="#208020"># Create history file.</font>

    set hist_file [open ${name}_history w]
    for {set i 0} {$i &lt; $state(n_study)} {incr i} {
	puts $hist_file &#34;***Computation on a new signal:&#34;
	puts $hist_file &#34;q Values   \[nb = [llength $state(q_lst)]\]:&#34;
	foreach q $state(q_lst) {
	    puts -nonewline $hist_file &#34;$q &#34;
	}
	puts $hist_file &#34;&#34;
	puts $hist_file &#34;Signal size : [expr $state(n_octave)*$state(n_voice)]&#34;
	puts $hist_file &#34;Signal name : $state(study_method)&#34;
	puts $hist_file &#34;&#34;
    }
    close $hist_file

    set base $state(baseSigName)

    <font color="#208020"># Create data files.</font>
    foreach q $state(q_lst) {
	set q_str [<a name="get_q_str(4)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	
	ssave ${base}_STq_$q_str ${name}_Pq.$q_str -ascii -noheader
	ssave ${base}_logSTq_$q_str ${name}_logsP.$q_str -ascii -noheader
	ssave ${base}_STqlogT_$q_str ${name}_PqlogP.$q_str -ascii -noheader
    }
}


<font color="#208020"># pf::thd --</font>
<font color="#208020"># usage: pf::thd pfId</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the Z(a,q), h(a,q) and D(a,q) signals from the STq and STqlogT </font>
<font color="#208020"># signals.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Options:</font>
<font color="#208020">#   -normalize: devide each Z(a,q) by N(a).</font>
<font color="#208020">#   -turbulence : compute taulog !!</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::thd_603">proc <a href="partFcts.tcl-annot.html#pf::thd">pf::thd</a></a></strong><a name="pf::thd"></a> {pfid args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    if {$state(n_study) == 0} {
	return -code error &#34;no current data for this pf id&#34;
    }

    set isNormalize no
    set isTurbulence no

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -normalize {
		set isNormalize yes
		set args [lreplace $args 0 0]
	    }
	    -turbulence {
		set isTurbulence yes
		set args [lreplace $args 0 0]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }


    set base $state(baseSigName)

    foreach q $state(q_lst) {
	set q_str [<a name="get_q_str(5)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	set STq      ${base}_STq_$q_str
	set STqlogT  ${base}_STqlogT_$q_str
	set STq2     ${base}_STq2_$q_str
	set STqlogT2 ${base}_STqlogT2_$q_str

	scomb $STq $STq     log(x)/log(2)              ${base}_tau$q_str -xnull
	scomb $STqlogT $STq x/(log(2)*y)               ${base}_h$q_str   -ynull
	scomb $STqlogT $STq ($q*x-y*log(y))/(y*log(2)) ${base}_D$q_str   -ynull
	
	<font color="#208020"># compute error bars for tau(q,a) from STq2</font>
	<font color="#208020"># Y=log(X) ==&gt; Delta(Y)=Delta(X)/X</font>
	set N $state(n_study)
	scomb $STq2 $STq sqrt((x/$N)-(y*y)/$N/$N)/x*$N ${base}_var_tau$q_str
	<font color="#208020"># compute error bars for h(q,a) from STq2 and STqlogT2</font>
	<font color="#208020"># Z=X/Y ==&gt; Delta(Z)/Z=Delta(X)/X+Delta(Y)/Y</font>
	scomb $STqlogT2 $STqlogT sqrt((x/$N)-(y*y)/$N/$N)/x*$N __tmp
	scomb ${base}_var_tau$q_str __tmp x+y __tmp
	scomb ${base}_h$q_str __tmp x*y ${base}_var_h$q_str
	<font color="#208020"># compute error bars for D(q,a) from STq2 and STqlogT2</font>
	<font color="#208020"># Delta(D)=q*Delta(h)+Delta(tau)</font>
	scomb ${base}_var_h$q_str ${base}_var_tau$q_str $q*x+y ${base}_var_D$q_str

    }

    if {$isTurbulence == &#34;yes&#34;} {
	foreach qturb $state(qturb_lst) {
	    set qturb_str [<a name="get_q_str(6)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qturb]
	    set SlogTq  ${base}_SlogTq_$qturb_str
	    <font color="#208020">#scomb $SlogTq $SlogTq   log(x)/log(2)    ${base}_taulog$qturb_str -xnull</font>
	}
    }

    if {$isNormalize == &#34;yes&#34;} {
	set q_str [<a name="get_q_str(7)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> 0]
	set tau0 ${base}_tau$q_str

	set n [ssize $tau0]
	set dx [sgetx0 $tau0]
	set x0 [sgetx0 $tau0]

	set b $x0
	set e [expr { $x0 + $dx*($n-1) }]

	exprr x2 0.2*x $b $e $n
	scomb $tau0 x2 y+x Na
	foreach q $state(q_lst) {
	    set q_str [<a name="get_q_str(8)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	    set tauq ${base}_tau$q_str

	    scomb $tauq Na x-y $tauq
	}
    }
}


<font color="#208020"># pf::thd_tsallis --</font>
<font color="#208020"># usage: pf::thd_tsallis pfId real</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the Ztsa(a,q), htsa(a,q) and Dtsa(a,q) signals from the SKqqtas, SKqqtsa_logT and SLqqtsa.</font>
<font color="#208020"># signals.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   real   - Tsallis parameter.</font>
<font color="#208020">#</font>
<font color="#208020"># Options:</font>
<font color="#208020">#   -normalize: devide each Ztsa(a,q) by N(a).</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::thd_tsallis_718">proc <a href="partFcts.tcl-annot.html#pf::thd_tsallis">pf::thd_tsallis</a></a></strong><a name="pf::thd_tsallis"></a> {pfid qtsa args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    if {$state(n_study) == 0} {
	return -code error &#34;no current data for this pf id&#34;
    }

    set isNormalize no

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -normalize {
		set isNormalize yes
		set args [lreplace $args 0 0]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }


    set base $state(baseSigName)
    set qtsa_str [<a name="get_q_str(9)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]
    
    <font color="#208020"># q    : temperature</font>
    <font color="#208020"># qtsa : parametre de tsallis</font>

    <font color="#208020"># initialisation</font>
    foreach q $state(q_lst) {
	set q_str [<a name="get_q_str(10)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set SKqqtsa      ${base}_SKqqtsa_${q_str}_${qtsa_str}
	set SKqqtsa_logT ${base}_SKqqtsalogT_${q_str}_${qtsa_str}
	set SLqqtsa      ${base}_SLqqtsa_${q_str}_${qtsa_str}
	
	scomb $SLqqtsa $SLqqtsa        log(x)/log(2)           ${base}_logZtsa${q_str}_${qtsa_str} -xnull
	scomb $SKqqtsa_logT $SKqqtsa   x/(log(2)*y)            ${base}_htsa${q_str}_${qtsa_str}   -ynull
	scomb $SKqqtsa $SLqqtsa (1-(x/pow(y,$qtsa)))/(1-$qtsa) ${base}_Dtsa${q_str}_${qtsa_str}   -ynull
    }
    
<font color="#208020">#    if {$isNormalize == &#34;yes&#34;} {</font>
<font color="#208020">#	set q_str [get_q_str 0]</font>
<font color="#208020">#	set tau0 ${base}_tau$q_str</font>
<font color="#208020">#</font>
<font color="#208020">#	set n [ssize $tau0]</font>
<font color="#208020">#	set dx [sgetx0 $tau0]</font>
<font color="#208020">#	set x0 [sgetx0 $tau0]</font>
<font color="#208020">#</font>
<font color="#208020">#	set b $x0</font>
<font color="#208020">#	set e [expr { $x0 + $dx*($n-1) }]</font>
<font color="#208020">#</font>
<font color="#208020">#	exprr x2 0.2*x $b $e $n</font>
<font color="#208020">#	scomb $tau0 x2 y+x Na</font>
<font color="#208020">#	foreach q $state(q_lst) {</font>
<font color="#208020">#	    set q_str [get_q_str $q]</font>
<font color="#208020">#</font>
<font color="#208020">#	    set tauq ${base}_tau$q_str</font>
<font color="#208020">#</font>
<font color="#208020">#	    scomb $tauq Na x-y $tauq</font>
<font color="#208020">#	}</font>
<font color="#208020">#    }</font>
}


<font color="#208020"># pf::GetRange --</font>
<font color="#208020"># usage: pf::GetRange pfId ...</font>
<font color="#208020">#</font>

<strong><a name="pf::GetRange_797">proc <a href="partFcts.tcl-annot.html#pf::GetRange">pf::GetRange</a></a></strong><a name="pf::GetRange"></a> {q defAMin defAMax rangeLst} {
    if {$rangeLst == {}} {
	return [list $defAMin $defAMax]
    }

    set zeMin $defAMin
    set zeMax $defAMax
    foreach {q2 aMin aMax} $rangeLst {
	if {$q &lt; $q2} {
	    return [list $zeMin $zeMax]
	}
	set zeMin $aMin
	set zeMax $aMax
    }

    return [list $zeMin $zeMax]
}


<font color="#208020"># pf::thdFit --</font>
<font color="#208020"># usage: pf::thdFit pfId real real [-rangelist list] [-onlyerror] [-hrange real real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Fit Z, h and D.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   pfId    - The pf id.</font>
<font color="#208020">#   2 reals - Range of the fit</font>
<font color="#208020">#</font>
<font color="#208020"># Options:</font>
<font color="#208020">#   -rangelist: Use different ranges of fit depending on the vqlue of q.</font>
<font color="#208020">#      list - list of triplets: q, min scale, max scale. Example: {-2 1 3 0 0.2</font>
<font color="#208020">#      2} means that for q up to -2 (exclude) we use the defaukt range, for q</font>
<font color="#208020">#      in [-2,0[ we use range [1,3] and for q greater or equal to 0 we use range</font>
<font color="#208020">#      [0.2,2].</font>
<font color="#208020">#   -onlyerror: Compute only the error for Z, h and D.</font>
<font color="#208020">#   -qlst     : Use only q_values between qmin and qmax</font>
<font color="#208020">#      - real: qmin</font>
<font color="#208020">#      - real: qmax</font>
<font color="#208020">#   -hrange: use a different range of fit the partition functions in h</font>
<font color="#208020">#      - real : aMin_h</font>
<font color="#208020">#      - real : aMax_h </font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::thdFit_842">proc <a href="partFcts.tcl-annot.html#pf::thdFit">pf::thdFit</a></a></strong><a name="pf::thdFit"></a> {pfid aMin aMax args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set rangeLst {}
    set isOnlyerror no
    set isqlst no

    set aMinH $aMin
    set aMaxH $aMax

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -rangelist {
		set rangeLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -onlyerror {
		set isOnlyerror yes
		set args [lreplace $args 0 0]
	    }
	    -qlst {
		set isqlst yes
		<font color="#208020"># q_lst2</font>
		set qMin [lindex $args 1]
		set qMax [lindex $args 2]
		set theqlst &#34;&#34;
		foreach q $state(q_lst) {
		    if {$q &gt;= $qMin &amp; $q &lt;= $qMax} {
			lappend theqlst $q
		    }
		}
		<font color="#208020">#echo $theqlst $state(q_lst)</font>
		set args [lreplace $args 0 2]
	    }
	    -hrange {
		set aMinH [lindex $args 1]
		set aMaxH [lindex $args 2]
		set args [lreplace $args 0 2]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }


    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-thdDone
    } result]
    if {$code == 1} {
	return -code error $result
    }

    if { $isqlst == &#34;yes&#34;} {
	set q_lst $theqlst
    } else {
	set q_lst $state(q_lst)
    }

    set name $state(baseSigName)

    set Z_fitLst [list]
    set sigmaZ_Lst [list]
    set D_fitLst [list]
    set sigmaD_fitLst [list]
    set h_fitLst [list]
    set sigmah_fitLst [list]
    foreach q $q_lst {
	set q_str [<a name="get_q_str(11)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	
	<a name="lassign(1)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a_min a_max} [GetRange $q $aMin $aMax $rangeLst]
	<a name="lassign(2)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a_minH a_maxH} [GetRange $q $aMinH $aMaxH $rangeLst]
	<font color="#208020"># normalisation</font>
	<font color="#208020">#scomb ${name}_tau$q_str ${name}_tau0p00 x-y ${name}_tau$q_str</font>
	<font color="#208020"># </font>
	<a name="lassign(3)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a b sigA} [sfit ${name}_tau$q_str $a_min $a_max]

	lappend Z_fitLst $a
	lappend sigmaZ_fitLst $sigA

	<a name="lassign(4)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a b sigA} [sfit ${name}_D$q_str $a_min $a_max]
	lappend D_fitLst $a
	lappend sigmaD_fitLst $sigA
	<font color="#208020">#echo toto</font>
	<a name="lassign(5)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a b sigA} [sfit ${name}_h$q_str $a_minH $a_maxH]
	lappend h_fitLst $a
	lappend sigmah_fitLst $sigA
    }
    if {$isOnlyerror == &#34;no&#34;} {
	screate ${name}_tq 0 1 $Z_fitLst -xy $q_lst
	screate ${name}_Dq 0 1 $D_fitLst -xy $q_lst
	screate ${name}_hq 0 1 $h_fitLst -xy $q_lst
    }
    
    screate ${name}_stq 0 1 $sigmaZ_fitLst -xy $q_lst
    screate ${name}_sDq 0 1 $sigmaD_fitLst -xy $q_lst
    screate ${name}_shq 0 1 $sigmah_fitLst -xy $q_lst

    return
}


<font color="#208020"># pf::ess --</font>
<font color="#208020"># usage: pf::ess pfId real real</font>
<font color="#208020">#</font>
<font color="#208020">#   Fit Z(q,a)/Z(q=0,a)</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   pfId    - The pf id.</font>
<font color="#208020">#   2 reals - Range of the fit</font>
<font color="#208020">#</font>
<font color="#208020"># Options:</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::ess_971">proc <a href="partFcts.tcl-annot.html#pf::ess">pf::ess</a></a></strong><a name="pf::ess"></a> {pfid aMin aMax args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set rangeLst {}
    set isZ no
    set isBoite no
    set q_lst $state(q_lst)

    <font color="#208020"># Arguments analysis</font>
    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set q_lst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -Z {
		set isZ &#34;yes&#34;
		set args [lreplace $args 0 0]
	    }
	    -boite {
		set isBoite &#34;yes&#34;
		set args [lreplace $args 0 0]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }
    
    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-thdDone
    } result]
    if {$code == 1} {
	return -code error $result
    }
    
    <font color="#208020">#set q_lst $state(q_lst)</font>
    

    set name $state(baseSigName)

    set Z_fitLst [list]
    set sigmaZ_Lst [list]
 
    set completeLst {}
    set sigLst {}

    if {$isBoite == &#34;yes&#34;} {
	s2fs ${name}_tau0p00 dd0 x y-3*x
    } else {
	s2fs ${name}_tau0p00 dd0  x y
    }

    foreach q $q_lst {
	
	set q_str [<a name="get_q_str(12)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	
	<a name="lassign(6)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a_min a_max} [GetRange $q $aMin $aMax $rangeLst]
	
	if {$q_str==&#34;0p00&#34;} {
	    <a name="echo(1)"><a href="./tkcon.tcl.html#echo_3895">echo</a></a> $q_str
	    scopy dd0 ${name}_tau2$q_str
	    set val [lindex [sget ${name}_tau2${q_str} 0] 0]
	    s2fs ${name}_tau2$q_str ${name}_tau2$q_str x y-$val
	} else {
	    <font color="#208020"># normalisation</font>
	    if {$isBoite == &#34;yes&#34;} {
		s2fs ${name}_tau$q_str ${name}_tau$q_str x y-0*x
		scomb ${name}_tau$q_str dd0 x-$q*y ${name}_tau2$q_str
		set val [lindex [sget ${name}_tau2${q_str} 0] 0]
		<font color="#208020">#s2fs ${name}_tau2$q_str ${name}_tau2$q_str x y+(0-3*$q)*x-$val</font>
		s2fs ${name}_tau2$q_str ${name}_tau2$q_str x y-$val
	    } else {
		s2fs ${name}_tau$q_str ${name}_tau$q_str x y
		scomb ${name}_tau$q_str dd0 x-$q*y ${name}_tau2$q_str
		set val [lindex [sget ${name}_tau2${q_str} 0] 0]
		<a name="echo(2)"><a href="./tkcon.tcl.html#echo_3895">echo</a></a> tata $q
		s2fs ${name}_tau2$q_str ${name}_tau2$q_str x y-$val
	    }
	
	}  
	<a name="lassign(7)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a b sigA} [sfit ${name}_tau2$q_str $a_min $a_max]
	
	lappend Z_fitLst $a
	lappend sigmaZ_fitLst $sigA
	
	lappend sigLst ${name}_tau2${q_str}
	
    }
    set completeLst [lappend completeLst ${sigLst}]
    
    <a name="echo(3)"><a href="./tkcon.tcl.html#echo_3895">echo</a></a> $completeLst

    screate ${name}_tqess 0 1 $Z_fitLst -xy $q_lst

    <a name="legendre2(1)"><a href="./legendre.tcl.html#legendre2_147">legendre2</a></a> ${name}_tqess -dh ${name}_Dhess
    scomb ${name}_Dhess ${name}_Dhess x+0 ${name}_Dhess
    
    set zeliste $sigLst

    <a name="echo(4)"><a href="./tkcon.tcl.html#echo_3895">echo</a></a> qqq $isZ

    if {$isZ==&#34;no&#34;} {
	sdisp ${name}_Dhess
	<font color="#208020">#mdisp 1 1 [list ${sigLst}]</font>
    } else {
	set code [catch {mdisp 1 1 [list $sigLst]} w]
	if {$code != 0} {
	    error $w $w
	}
	
	${w} switch_allgraph_flag
	${w} gr set_disp_mode all
	
	$w setColorsByList {black red orange yellow green darkgreen blue slateblue brown }
	
	set itemList {}
	foreach value $q_lst {
	    set itemList [lappend itemlist [list %c $value]]
	}
	eval $w setLabelsItemsByList $itemList
	
	${w} setLabel &#34;$state(comments)\n($state(a_min), $state(n_octave), \
		$state(n_voice)) ; $state(n_study)\n &#34; 3
	
	${w}gr0000 set_label {black &#34;Z(a, q)/Z^q(a,q=0), q = &#34;} allSigLabel
	
	${w} gr init_disp
	
	${w} gr set_box_coord 0 5 -1.4 1
	
	return $w
    }
}


<font color="#208020"># pf::thdFit_tsallis --</font>
<font color="#208020"># usage: pf::thdFit_tsallis pfId real real real [-rangelist list] [-onlyerror]</font>
<font color="#208020">#</font>
<font color="#208020">#   Fit Ztsa, htsa and Dtsa.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   pfId    - The pf id.</font>
<font color="#208020">#   2 reals - Range of the fit</font>
<font color="#208020">#   1 real  - qtsa (tsallis parameter)</font>
<font color="#208020">#</font>
<font color="#208020"># Options:</font>
<font color="#208020">#   -rangelist: Use different ranges of fit depending on the vqlue of q.</font>
<font color="#208020">#      list - list of triplets: q, min scale, max scale. Example: {-2 1 3 0 0.2</font>
<font color="#208020">#      2} means that for q up to -2 (exclude) we use the defaukt range, for q</font>
<font color="#208020">#      in [-2,0[ we use range [1,3] and for q greater or equal to 0 we use range</font>
<font color="#208020">#      [0.2,2].</font>
<font color="#208020">#   -onlyerror: Compute only the error for Z, h and D.</font>
<font color="#208020">#   -qlst     : Use only q_values between qmin and qmax</font>
<font color="#208020">#      - real: qmin</font>
<font color="#208020">#      - real: qmax</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::thdFit_tsallis_1142">proc <a href="partFcts.tcl-annot.html#pf::thdFit_tsallis">pf::thdFit_tsallis</a></a></strong><a name="pf::thdFit_tsallis"></a> {pfid aMin aMax qtsa args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set rangeLst {}
    set isOnlyerror no
    set isqlst no

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -rangelist {
		set rangeLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -onlyerror {
		set isOnlyerror yes
		set args [lreplace $args 0 0]
	    }
	    -qlst {
		set isqlst yes
		<font color="#208020"># q_lst2</font>
		set qMin [lindex $args 1]
		set qMax [lindex $args 2]
		set theqlst &#34;&#34;
		foreach q $state(q_lst) {
		    if {$q &gt;= $qMin &amp; $q &lt;= $qMax} {
			lappend theqlst $q
		    }
		}
		<font color="#208020">#echo $theqlst $state(q_lst)</font>
		set args [lreplace $args 0 2]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    <font color="#208020"># evenetuellement modifie ce qui suit en ajoutant un thdtsallisDone !!</font>
    set code [catch {
	StateCheck $pfid \
		-dataExist
    } result]
    if {$code == 1} {
	return -code error $result
    }

    if { $isqlst == &#34;yes&#34;} {
	set q_lst $theqlst
    } else {
	set q_lst $state(q_lst)
    }

    set name $state(baseSigName)

    set Ztsa_fitLst       [list]
    set sigmaZtsa_Lst     [list]
    set Dtsa_fitLst       [list]
    set sigmaDtsa_fitLst  [list]
    set htsa_fitLst       [list]
    set sigmahtsa_fitLst  [list]
    
    set qtsa_str [<a name="get_q_str(13)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]
    foreach q $q_lst {
	set q_str [<a name="get_q_str(14)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	
	<a name="lassign(8)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a_min a_max} [GetRange $q $aMin $aMax $rangeLst]
<font color="#208020">#	echo $q $aMin $aMax</font>
	<a name="lassign(9)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a b sigA} [sfit ${name}_logZtsa${q_str}_${qtsa_str} $a_min $a_max]
<font color="#208020">#	echo $a</font>
	lappend Ztsa_fitLst $a
	lappend sigmaZtsa_fitLst $sigA

	<a name="lassign(10)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a b sigA} [sfit ${name}_Dtsa${q_str}_${qtsa_str} $a_min $a_max]
	lappend Dtsa_fitLst $a
	lappend sigmaDtsa_fitLst $sigA
	<font color="#208020">#echo toto</font>
	<a name="lassign(11)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {a b sigA} [sfit ${name}_htsa${q_str}_${qtsa_str} $a_min $a_max]
	lappend htsa_fitLst $a
	lappend sigmahtsa_fitLst $sigA
    }
    if {$isOnlyerror == &#34;no&#34;} {
	screate ${name}_tq_${qtsa_str} 0 1 $Ztsa_fitLst -xy $q_lst
	screate ${name}_Dq_${qtsa_str} 0 1 $Dtsa_fitLst -xy $q_lst
	screate ${name}_hq_${qtsa_str} 0 1 $htsa_fitLst -xy $q_lst
    }
    
    screate ${name}_stq_${qtsa_str} 0 1 $sigmaZtsa_fitLst -xy $q_lst
    screate ${name}_sDq_${qtsa_str} 0 1 $sigmaDtsa_fitLst -xy $q_lst
    screate ${name}_shq_${qtsa_str} 0 1 $sigmahtsa_fitLst -xy $q_lst

    return
}


<font color="#208020"># pf::disp --</font>
<font color="#208020"># usage : pf::disp pfId [-qlist list] [-h float]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display Z(a,q), h(a,q), and D(a,q) signals.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -qlist : Display only some values of q.</font>
<font color="#208020">#     list - list of the values of q to display. The default is all the values.</font>
<font color="#208020">#   -h     : Display h(a,q)-h0*ln(a)</font>
<font color="#208020">#     h0   - float</font>
<font color="#208020">#   -tsallis real : Display logZtsa(a,q), htsa(a,q) and Dtsa(a,q)</font>
<font color="#208020">#                   for some value of tsallis parameter.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the object that handle the window.</font>

<strong><a name="pf::disp_1266">proc <a href="partFcts.tcl-annot.html#pf::disp">pf::disp</a></a></strong><a name="pf::disp"></a> {pfid args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set qLst $state(q_lst)
    set base $state(baseSigName)
    set h0 0
    set ish no
    set isTsallis no

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set qLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -h {
		set h0 [lindex $args 1]
		set args [lreplace $args 0 1]
		<font color="#208020">#echo $h0</font>
		set ish yes
	    }
	    -tsallis {
		set qtsa [lindex $args 1]
		set args [lreplace $args 0 1]
		set isTsallis yes
		set qtsa_str [<a name="get_q_str(15)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]
		<font color="#208020">#dputs &#34;istsallis $isTsallis&#34;</font>
	    }	    
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    <font color="#208020"># Create the list of signals to pass to mdisp command.</font>
    set completeLst {}
    set sigLst {}

    if {$isTsallis == &#34;yes&#34;} {
	foreach q $qLst {
	    set q_str [<a name="get_q_str(16)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${base}_logZtsa${q_str}_${qtsa_str}]
	}
	
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $qLst {
	    set value_lst {}
	    set q_str [<a name="get_q_str(17)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${base}_htsa${q_str}_${qtsa_str}]
	}
	
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $qLst {
	    set q_str [<a name="get_q_str(18)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${base}_Dtsa${q_str}_${qtsa_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
	
	<font color="#208020">#if {[gettype ${base}_tq_${qtsa_str}] == &#34;S&#34;} {</font>
	<font color="#208020">#    lappend completeLst [list ${base}_tq ${base}_hq ${base}_Dq]</font>
	<font color="#208020">#}</font>
	
	set code [catch {mdisp 1 3 ${completeLst}} w]
	if {$code != 0} {
	    error $w $w
	}
	
	${w} switch_allgraph_flag
	${w} gr set_disp_mode all
	if {$state(dimension) == &#34;2D&#34;} {
	    set source &#34;image(s)&#34;
	} else {
	    set source &#34;signal(s)&#34;
	}
	${w} setLabel &#34;Tsallis : qtsallis = $qtsa; $state(comments)\n($state(a_min), $state(n_octave), \
		$state(n_voice)) ; $state(n_study) $source\n$state(study_method)&#34; 3
	
	$w setColorsByList {black red green blue yellow brown slateblue}
	
	set itemList {}
	foreach value $qLst {
	    set itemList [lappend itemlist [list %c $value]]
	}
	eval $w setLabelsItemsByList $itemList
	
	${w}gr0000 set_label {black &#34;logZtsa(a, q), q = &#34;} allSigLabel
	${w}gr0002 set_label {black &#34;Dtsa(a, q), q = &#34;} allSigLabel
	${w}gr0001 set_label {black &#34;htsa(a, q)-h0*ln(a), q = &#34;} allSigLabel
    } else {	
	<font color="#208020"># create signal h0loga</font>
	set q0 [lindex $qLst 0]
	set q0_str [<a name="get_q_str(19)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q0]
	set a0 [sgetx0 ${base}_h${q0_str}]
	set da0 [sgetdx ${base}_h${q0_str}]
	set asize [ssize ${base}_h${q0_str}]
	
	foreach q $qLst {
	    set q_str [<a name="get_q_str(20)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${base}_tau${q_str}]
	}
	
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $qLst {
	    set value_lst {}
	    set q_str [<a name="get_q_str(21)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    <font color="#208020">#set a0 [sgetx0 ${base}_h${q_str}]</font>
	    <font color="#208020">#set da0 [sgetdx ${base}_h${q_str}]</font>
	    <font color="#208020">#set asize [ssize ${base}_h${q_str}]</font>
	    if { $ish == &#34;yes&#34;} {
		set cste [lindex [sget ${base}_h${q_str} 0] 0]
	    } else {
		set cste 0
		<font color="#208020">#echo $cste</font>
	    }
	    for {set k 0} { $k &lt; $asize} {incr k} {
		set hloga_value [expr $h0*($a0+$k*$da0)+$cste]
		lappend value_lst $hloga_value
	    }
	    screate h0loga $a0 $da0 $value_lst
	    
	    scomb ${base}_h${q_str} h0loga x-y ${base}_h${q_str}_disp
	    set sigLst [lappend sigLst ${base}_h${q_str}_disp]
	}
	
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $qLst {
	    set q_str [<a name="get_q_str(22)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${base}_D${q_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
	
	if {[gettype ${base}_tq] == &#34;S&#34;} {
	    lappend completeLst [list ${base}_tq ${base}_hq ${base}_Dq]
	}
	
	set code [catch {mdisp 1 3 ${completeLst}} w]
	if {$code != 0} {
	    error $w $w
	}
	
	${w} switch_allgraph_flag
	${w} gr set_disp_mode all
	if {$state(dimension) == &#34;2D&#34;} {
	    set source &#34;image(s)&#34;
	} else {
	    set source &#34;signal(s)&#34;
	}
	${w} setLabel &#34;$state(comments)\n($state(a_min), $state(n_octave), \
		$state(n_voice)) ; $state(n_study) $source\n$state(study_method)&#34; 3
	
	$w setColorsByList {black red green blue yellow brown slateblue}
	
	set itemList {}
	foreach value $qLst {
	    set itemList [lappend itemlist [list %c $value]]
	}
	eval $w setLabelsItemsByList $itemList
	
	${w}gr0000 set_label {black &#34;Z(a, q), q = &#34;} allSigLabel
	<font color="#208020">#${w} gr0000 set_box_coord 0 5 -1.4 1</font>
	
	${w}gr0002 set_label {black &#34;D(a, q), q = &#34;} allSigLabel
	<font color="#208020">#${w} gr0002 set_box_coord 0 5 -1.4 1</font>
	
	${w}gr0001 set_label {black &#34;h(a, q)-h0*ln(a), q = &#34;} allSigLabel
	<font color="#208020">#${w} gr0001 set_box_coord 0 5 -1.4 1</font>
    }

    ${w} gr init_disp
    eval ${w} print zhd.eps
    return $w
}


<font color="#208020"># pf::disp2 --</font>
<font color="#208020"># usage : pf::disp pfId [-qlist list] [-h float]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display h(a,q), and D(a,q) signals.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -qlist : Display only some values of q.</font>
<font color="#208020">#     list - list of the values of q to display. The default is all the values.</font>
<font color="#208020">#   -h     : Display h(a,q)-h0*ln(a)</font>
<font color="#208020">#     h0   - float</font>
<font color="#208020">#   -tsallis real : Display logZtsa(a,q), htsa(a,q) and Dtsa(a,q)</font>
<font color="#208020">#                   for some value of tsallis parameter.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the object that handle the window.</font>

<strong><a name="pf::disp2_1482">proc <a href="partFcts.tcl-annot.html#pf::disp2">pf::disp2</a></a></strong><a name="pf::disp2"></a> {pfid args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set qLst $state(q_lst)
    set base $state(baseSigName)
    set h0 0
    set ish no
    set isTsallis no

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set qLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -h {
		set h0 [lindex $args 1]
		set args [lreplace $args 0 1]
		<font color="#208020">#echo $h0</font>
		set ish yes
	    }
	    -tsallis {
		set qtsa [lindex $args 1]
		set args [lreplace $args 0 1]
		set isTsallis yes
		set qtsa_str [<a name="get_q_str(23)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]
		<font color="#208020">#dputs &#34;istsallis $isTsallis&#34;</font>
	    }	    
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    <font color="#208020"># Create the list of signals to pass to mdisp command.</font>
    set completeLst {}
    set sigLst {}

    if {$isTsallis == &#34;yes&#34;} {
	foreach q $qLst {
	    set value_lst {}
	    set q_str [<a name="get_q_str(24)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${base}_htsa${q_str}_${qtsa_str}]
	}
	
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $qLst {
	    set q_str [<a name="get_q_str(25)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${base}_Dtsa${q_str}_${qtsa_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
	
	<font color="#208020">#if {[gettype ${base}_tq_${qtsa_str}] == &#34;S&#34;} {</font>
	<font color="#208020">#    lappend completeLst [list ${base}_tq ${base}_hq ${base}_Dq]</font>
	<font color="#208020">#}</font>
	
	set code [catch {mdisp 1 2 ${completeLst}} w]
	if {$code != 0} {
	    error $w $w
	}
	
	${w} switch_allgraph_flag
	${w} gr set_disp_mode all
	if {$state(dimension) == &#34;2D&#34;} {
	    set source &#34;image(s)&#34;
	} else {
	    set source &#34;signal(s)&#34;
	}
	${w} setLabel &#34;Tsallis : qtsallis = $qtsa; $state(comments)\n($state(a_min), $state(n_octave), \
		$state(n_voice)) ; $state(n_study) $source\n$state(study_method)&#34; 3
	
	$w setColorsByList {black red green blue yellow brown slateblue}
	
	set itemList {}
	foreach value $qLst {
	    set itemList [lappend itemlist [list %c $value]]
	}
	eval $w setLabelsItemsByList $itemList
	
	${w}gr0001 set_label {black &#34;Dtsa(a, q), q = &#34;} allSigLabel
	${w}gr0000 set_label {black &#34;htsa(a, q), q = &#34;} allSigLabel
    } else {	
	<font color="#208020"># create signal h0loga</font>
	set q0 [lindex $qLst 0]
	set q0_str [<a name="get_q_str(26)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q0]
	set a0 [sgetx0 ${base}_h${q0_str}]
	set da0 [sgetdx ${base}_h${q0_str}]
	set asize [ssize ${base}_h${q0_str}]
	
	foreach q $qLst {
	    set value_lst {}
	    set q_str [<a name="get_q_str(27)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    <font color="#208020">#set a0 [sgetx0 ${base}_h${q_str}]</font>
	    <font color="#208020">#set da0 [sgetdx ${base}_h${q_str}]</font>
	    <font color="#208020">#set asize [ssize ${base}_h${q_str}]</font>
	    if { $ish == &#34;yes&#34;} {
		set cste [lindex [sget ${base}_h${q_str} 0] 0]
	    } else {
		set cste 0
		<font color="#208020">#echo $cste</font>
	    }
	    for {set k 0} { $k &lt; $asize} {incr k} {
		set hloga_value [expr $h0*($a0+$k*$da0)+$cste]
		lappend value_lst $hloga_value
	    }
	    screate h0loga $a0 $da0 $value_lst
	    
	    scomb ${base}_h${q_str} h0loga x-y ${base}_h${q_str}_disp
	    set sigLst [lappend sigLst ${base}_h${q_str}_disp]
	}
	
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $qLst {
	    set q_str [<a name="get_q_str(28)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${base}_D${q_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
	
	if {[gettype ${base}_tq] == &#34;S&#34;} {
	    lappend completeLst [list ${base}_tq ${base}_hq ${base}_Dq]
	}
	
	set code [catch {mdisp 1 2 ${completeLst}} w]
	if {$code != 0} {
	    error $w $w
	}
	
	${w} switch_allgraph_flag
	${w} gr set_disp_mode all
	if {$state(dimension) == &#34;2D&#34;} {
	    set source &#34;image(s)&#34;
	} else {
	    set source &#34;signal(s)&#34;
	}
	<font color="#208020">#${w} setLabel &#34;$state(comments)\n($state(a_min), $state(n_octave), \</font>
	<font color="#208020">#	$state(n_voice)) ; $state(n_study) $source\n$state(study_method)&#34; 3</font>
	${w} setLabel &#34;&#34; 
	
	$w setColorsByList {black red green blue yellow brown slateblue}
	
	set itemList {}
	foreach value $qLst {
	    set itemList [lappend itemlist [list %c $value]]
	}
	eval $w setLabelsItemsByList $itemList
	
	${w}gr0001 set_label {black &#34;D(a, q), q = &#34;} allSigLabel
	<font color="#208020">#${w} gr0002 set_box_coord 0 5 -1.4 1</font>
	
	${w}gr0000 set_label {black &#34;h(a, q), q = &#34;} allSigLabel
	<font color="#208020">#${w} gr0001 set_box_coord 0 5 -1.4 1</font>
    }

    ${w} gr init_disp
    eval ${w} print zhd.eps
    return $w
}


<font color="#208020"># pf::disp3 --</font>
<font color="#208020"># usage : pf::disp3 pfId1 pfId2 [-qlist list] [-h float]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display Z(a,q), h(a,q), and D(a,q) signals.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId's   - The pf id's.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -qlist : Display only some values of q.</font>
<font color="#208020">#     list - list of the values of q to display. The default is all the values.</font>
<font color="#208020">#   -h     : Display h(a,q)-h0*ln(a)</font>
<font color="#208020">#     h0   - float</font>
<font color="#208020">#   -shift : shift partition functions h(a,q) of pfId2 by given parameter. </font>
<font color="#208020">#     s    - float</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the object that handle the window.</font>

<strong><a name="pf::disp3_1681">proc <a href="partFcts.tcl-annot.html#pf::disp3">pf::disp3</a></a></strong><a name="pf::disp3"></a> {pfid1 pfid2 args} {
    set pfid1 [CheckPfid $pfid1]
    if {$pfid1 == 0} {
	return -code error &#34;wrong pf id1&#34;
    }
    variable $pfid1
    upvar 0 $pfid1 state1

    set pfid2 [CheckPfid $pfid2]
    if {$pfid2 == 0} {
	return -code error &#34;wrong pf id2&#34;
    }
    variable $pfid2
    upvar 0 $pfid2 state2

    set code [catch {
	StateCheck $pfid1 \
		-dataExist
	StateCheck $pfid2 \
		-dataExist
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set qLst $state1(q_lst)
    set base1 $state1(baseSigName)
    set base2 $state2(baseSigName)
    set h0 0
    set ish no
    set isshift no
    set shift 0.0

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set qLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -h {
		set h0 [lindex $args 1]
		set args [lreplace $args 0 1]
		<font color="#208020">#echo $h0</font>
		set ish yes
	    }
	    -shift {
		set shift [lindex $args 1]
		set args [lreplace $args 0 1]
		set isshift yes
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }
    
    <font color="#208020"># Create the list of signals to pass to mdisp command.</font>
    set completeLst {}
    set sigLst {}
    
    <font color="#208020"># create signal h0loga</font>
    set q0 [lindex $qLst 0]
    set q0_str [<a name="get_q_str(29)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q0]
    set a0 [sgetx0 ${base1}_h${q0_str}]
    set da0 [sgetdx ${base1}_h${q0_str}]
    set asize [ssize ${base1}_h${q0_str}]
    
    foreach q $qLst {
	set q_str [<a name="get_q_str(30)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set sigLst [lappend sigLst ${base1}_tau${q_str}]
	set sigLst [lappend sigLst ${base2}_tau${q_str}]
    }
    
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    foreach q $qLst {
	set value_lst {}
	set q_str [<a name="get_q_str(31)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	<font color="#208020">#set a0 [sgetx0 ${base}_h${q_str}]</font>
	<font color="#208020">#set da0 [sgetdx ${base}_h${q_str}]</font>
	<font color="#208020">#set asize [ssize ${base}_h${q_str}]</font>
	if { $ish == &#34;yes&#34;} {
	    set cste [lindex [sget ${base1}_h${q_str} 0] 0]
	} else {
	    set cste 0
	    <font color="#208020">#echo $cste</font>
	}
	for {set k 0} { $k &lt; $asize} {incr k} {
	    set hloga_value [expr $h0*($a0+$k*$da0)+$cste]
	    lappend value_lst $hloga_value
	}
	screate h0loga $a0 $da0 $value_lst
	
	scomb ${base1}_h${q_str} h0loga x-y ${base1}_h${q_str}_disp
	scomb ${base2}_h${q_str} h0loga x-y-$shift ${base2}_h${q_str}_disp
	set sigLst [lappend sigLst ${base1}_h${q_str}_disp]
	set sigLst [lappend sigLst ${base2}_h${q_str}_disp]
    }
    
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    foreach q $qLst {
	set q_str [<a name="get_q_str(32)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set sigLst [lappend sigLst ${base1}_D${q_str}]
	set sigLst [lappend sigLst ${base2}_D${q_str}]
    }
    set completeLst [lappend completeLst ${sigLst}]
	
    if {[gettype ${base1}_tq] == &#34;S&#34;} {
	lappend completeLst [list ${base1}_tq ${base1}_hq ${base1}_Dq]
    }
    
    set code [catch {mdisp 1 3 ${completeLst}} w]
    if {$code != 0} {
	error $w $w
    }
    
    ${w} switch_allgraph_flag
    ${w} gr set_disp_mode all
    if {$state1(dimension) == &#34;2D&#34;} {
	set source &#34;image(s)&#34;
    } else {
	set source &#34;signal(s)&#34;
    }
    ${w} setLabel &#34;$state1(comments)\n($state1(a_min), $state1(n_octave), \
	    $state1(n_voice)) ; $state1(n_study) \
	    $source\n$state1(study_method)&#34; 3
    
    <font color="#208020">#$w setColorsByList {red blue red blue red blue red blue red blue red blue red blue red blue }</font>
    $w setColorsByList {red blue magenta slateblue red blue magenta slateblue red blue red blue red blue red blue }
    
    set itemList {}
    foreach value $qLst {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $w setLabelsItemsByList $itemList
    
    ${w}gr0000 set_label {black &#34;Z(a, q), q = &#34;} allSigLabel
    <font color="#208020">#${w} gr0000 set_box_coord 0 5 -1.4 1</font>
    
    ${w}gr0002 set_label {black &#34;D(a, q), q = &#34;} allSigLabel
    <font color="#208020">#${w} gr0002 set_box_coord 0 5 -1.4 1</font>
    
    ${w}gr0001 set_label {black &#34;h(a, q)-h0*ln(a), q = &#34;} allSigLabel
    <font color="#208020">#${w} gr0001 set_box_coord 0 5 -1.4 1</font>

    
    ${w} gr init_disp
    <font color="#208020">#eval ${w} print zhd.eps</font>
    return $w
}

<font color="#208020"># pf::disp3b --</font>
<font color="#208020"># usage : pf::disp3 pfId1 pfId2 pfId3 [-qlist list] [-h float]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display Z(a,q), h(a,q), and D(a,q) signals.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId's   - The pf id's.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -qlist : Display only some values of q.</font>
<font color="#208020">#     list - list of the values of q to display. The default is all the values.</font>
<font color="#208020">#   -h     : Display h(a,q)-h0*ln(a)</font>
<font color="#208020">#     h0   - float</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the object that handle the window.</font>

<strong><a name="pf::disp3b_1856">proc <a href="partFcts.tcl-annot.html#pf::disp3b">pf::disp3b</a></a></strong><a name="pf::disp3b"></a> {pfid1 pfid2 pfid3 args} {
    set pfid1 [CheckPfid $pfid1]
    if {$pfid1 == 0} {
	return -code error &#34;wrong pf id1&#34;
    }
    variable $pfid1
    upvar 0 $pfid1 state1

    set pfid2 [CheckPfid $pfid2]
    if {$pfid2 == 0} {
	return -code error &#34;wrong pf id2&#34;
    }
    variable $pfid2
    upvar 0 $pfid2 state2

    set pfid3 [CheckPfid $pfid3]
    if {$pfid3 == 0} {
	return -code error &#34;wrong pf id3&#34;
    }
    variable $pfid3
    upvar 0 $pfid3 state3

    set code [catch {
	StateCheck $pfid1 \
		-dataExist
	StateCheck $pfid2 \
		-dataExist
	StateCheck $pfid3 \
		-dataExist
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set qLst $state1(q_lst)
    set base1 $state1(baseSigName)
    set base2 $state2(baseSigName)
    set base3 $state3(baseSigName)
    set h0 0
    set ish no

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set qLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -h {
		set h0 [lindex $args 1]
		set args [lreplace $args 0 1]
		<font color="#208020">#echo $h0</font>
		set ish yes
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }
    
    <font color="#208020"># Create the list of signals to pass to mdisp command.</font>
    set completeLst {}
    set sigLst {}
    
    <font color="#208020"># create signal h0loga</font>
    set q0 [lindex $qLst 0]
    set q0_str [<a name="get_q_str(33)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q0]
    set a0 [sgetx0 ${base1}_h${q0_str}]
    set da0 [sgetdx ${base1}_h${q0_str}]
    set asize [ssize ${base1}_h${q0_str}]
    
    foreach q $qLst {
	set q_str [<a name="get_q_str(34)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set sigLst [lappend sigLst ${base1}_tau${q_str}]
	set sigLst [lappend sigLst ${base2}_tau${q_str}]
	set sigLst [lappend sigLst ${base3}_tau${q_str}]
    }
    
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    foreach q $qLst {
	set value_lst {}
	set q_str [<a name="get_q_str(35)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	<font color="#208020">#set a0 [sgetx0 ${base}_h${q_str}]</font>
	<font color="#208020">#set da0 [sgetdx ${base}_h${q_str}]</font>
	<font color="#208020">#set asize [ssize ${base}_h${q_str}]</font>
	if { $ish == &#34;yes&#34;} {
	    set cste [lindex [sget ${base1}_h${q_str} 0] 0]
	} else {
	    set cste 0
	    <font color="#208020">#echo $cste</font>
	}
	for {set k 0} { $k &lt; $asize} {incr k} {
	    set hloga_value [expr $h0*($a0+$k*$da0)+$cste]
	    lappend value_lst $hloga_value
	}
	screate h0loga $a0 $da0 $value_lst
	
	scomb ${base1}_h${q_str} h0loga x-y ${base1}_h${q_str}_disp
	scomb ${base2}_h${q_str} h0loga x-y ${base2}_h${q_str}_disp
	scomb ${base3}_h${q_str} h0loga x-y ${base3}_h${q_str}_disp
	set sigLst [lappend sigLst ${base1}_h${q_str}_disp]
	set sigLst [lappend sigLst ${base2}_h${q_str}_disp]
	set sigLst [lappend sigLst ${base3}_h${q_str}_disp]
    }
    
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    foreach q $qLst {
	set q_str [<a name="get_q_str(36)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set sigLst [lappend sigLst ${base1}_D${q_str}]
	set sigLst [lappend sigLst ${base2}_D${q_str}]
	set sigLst [lappend sigLst ${base3}_D${q_str}]
    }
    set completeLst [lappend completeLst ${sigLst}]
	
    if {[gettype ${base1}_tq] == &#34;S&#34;} {
	lappend completeLst [list ${base1}_tq ${base1}_hq ${base1}_Dq]
    }
    
    set code [catch {mdisp 1 3 ${completeLst}} w]
    if {$code != 0} {
	error $w $w
    }
    
    ${w} switch_allgraph_flag
    ${w} gr set_disp_mode all
    if {$state1(dimension) == &#34;2D&#34;} {
	set source &#34;image(s)&#34;
    } else {
	set source &#34;signal(s)&#34;
    }
    ${w} setLabel &#34;$state1(comments)\n($state1(a_min), $state1(n_octave), \
	    $state1(n_voice)) ; $state1(n_study) \
	    $source\n$state1(study_method)&#34; 3
    
    $w setColorsByList {red blue black red blue black red blue black red blue black red blue black red blue black red blue black red blue }
    
    set itemList {}
    foreach value $qLst {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $w setLabelsItemsByList $itemList
    
    ${w}gr0000 set_label {black &#34;Z(a, q), q = &#34;} allSigLabel
    <font color="#208020">#${w} gr0000 set_box_coord 0 5 -1.4 1</font>
    
    ${w}gr0002 set_label {black &#34;D(a, q), q = &#34;} allSigLabel
    <font color="#208020">#${w} gr0002 set_box_coord 0 5 -1.4 1</font>
    
    ${w}gr0001 set_label {black &#34;h(a, q)-h0*ln(a), q = &#34;} allSigLabel
    <font color="#208020">#${w} gr0001 set_box_coord 0 5 -1.4 1</font>

    
    ${w} gr init_disp
    <font color="#208020">#eval ${w} print zhd.eps</font>
    return $w
}


<font color="#208020"># pf::disphaq --</font>
<font color="#208020"># usage : pf::disphaq pfId [-qlist list] [-h float]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display hh(a,q) = h(a,q) [ -h0*ln(a) - hh(a0,q)] signals.</font>
<font color="#208020">#  notice that : at scale a0 hh(a,q) equals ZERO !!</font>
<font color="#208020">#  a0 is set at scale 1 (log(a)=1 base 2)</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -qlist : Display only some values of q.</font>
<font color="#208020">#     list - list of the values of q to display. The default is all the values.</font>
<font color="#208020">#   -h     : Display h(a,q)-h0*ln(a)</font>
<font color="#208020">#     h0   - float (default is zero)</font>
<font color="#208020">#   -a0    : Display h(a,q)-cste with cste = h(a0,q)</font>
<font color="#208020">#     oct     - integer (between 0 and noct-1   -&gt; see parameters.tcl)</font>
<font color="#208020">#     voice   - integer (between 0 and nvoice-1 -&gt; see parameters.tcl)</font>
<font color="#208020">#            log(a0) = $oct+($voice/double($nvoice))</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the object that handle the window.</font>

<strong><a name="pf::disphaq_2042">proc <a href="partFcts.tcl-annot.html#pf::disphaq">pf::disphaq</a></a></strong><a name="pf::disphaq"></a> {pfid args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-thdDone
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set qLst $state(q_lst)
    set base $state(baseSigName)
    set h0 0

    set ish no
    set isa0 no

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set qLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -h {
		set h0 [lindex $args 1]
		set args [lreplace $args 0 1]
		<font color="#208020">#echo $h0</font>
		set ish yes
	    }
	    -a0 {
		set oct [lindex $args 1]
		set voice [lindex $args 2]
		set args [lreplace $args 0 2]
		set isa0 yes
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }
    <font color="#208020">#echo $h0</font>

    <font color="#208020"># create signal h0loga</font>
    set q0 [lindex $qLst 0]
    set q0_str [<a name="get_q_str(37)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q0]
    set a0 [sgetx0 ${base}_h${q0_str}]
    set da0 [sgetdx ${base}_h${q0_str}]
    set asize [ssize ${base}_h${q0_str}]
    set noct $state(n_octave)
    set nvoice $state(n_voice)

    if { $isa0 == &#34;yes&#34; } {
	set loga0 [expr $oct*$nvoice+$voice]
	if { ($loga0 &gt;= $asize) || ($loga0&lt;0)} {
	    return -code error &#34;wrong oct and voice&#34;
	} else {
	}
    } else {
	set loga0 0
    }


    <font color="#208020"># Create the list of signals to pass to mdisp command.</font>

    set completeLst {}
    set sigLst {}
    foreach q $qLst {
	set value_lst {}
	set q_str [<a name="get_q_str(38)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	
	<font color="#208020"># on va retrancher hh(a0,q)</font>
	if { $isa0 == &#34;yes&#34;} {
	    set cste [lindex [sget ${base}_h${q_str} $loga0] 0]
	} else {
	    set cste 0
	}
	for {set k 0} { $k &lt; $asize} {incr k} {
	    set hloga_value [expr $h0*($a0+$k*$da0-$loga0*1.0/$nvoice)+$cste]
	    lappend value_lst $hloga_value
	}
	screate h0loga $a0 $da0 $value_lst
	
	scomb ${base}_h${q_str} h0loga x-y ${base}_h${q_str}_disp2
	set sigLst [lappend sigLst ${base}_h${q_str}_disp2]
    }

    set completeLst [lappend completeLst ${sigLst}]

    if {[gettype ${base}_tq] == &#34;S&#34;} {
	lappend completeLst [list ${base}_hq ]
    }

    set code [catch {mdisp 1 1 ${completeLst}} w]
    if {$code != 0} {
	error $w $w
    }

    ${w} switch_allgraph_flag
    ${w} gr set_disp_mode all
    if {$state(dimension) == &#34;2D&#34;} {
	set source &#34;image(s)&#34;
    } else {
	set source &#34;signal(s)&#34;
    }
    set a00 [format &#34;%.2f&#34; [expr ($loga0)*1.0/($nvoice)]]

    ${w} setLabel &#34;$state(comments)\n($state(a_min), $state(n_octave), \
	    $state(n_voice)) ; $state(n_study) $source\n h0 = $h0 et \
	    a0 = $a00&#34; 4

    $w setColorsByList {black red green blue yellow brown slateblue}

    set itemList {}
    foreach value $qLst {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $w setLabelsItemsByList $itemList

<font color="#208020">#    ${w}gr0000 set_label {black &#34;Z(a, q), q = &#34;} allSigLabel</font>
<font color="#208020">#    ${w}gr0002 set_label {black &#34;D(a, q), q = &#34;} allSigLabel</font>
    ${w}gr0000 set_label {black &#34;h(a, q) -h0*ln(a) -h(a0,q), q = &#34;} allSigLabel

    ${w} gr init_disp

    ${w} gr set_box_coord 0 5 -1.4 1
    eval ${w} print haq.eps
    return $w
}


<font color="#208020"># pf::disp2pf --</font>
<font color="#208020"># usage : pf::disp2pf pfId1 pfId2 [-qlist list]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display some signals corresponding to pfId1 and pfId2.</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId1 pfId2   - The pf id's.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -qlist : Display only some values of q.</font>
<font color="#208020">#     list - list of the values of q to display. The default is all the values.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the object that handle the window.</font>

<strong><a name="pf::disp2pf_2199">proc <a href="partFcts.tcl-annot.html#pf::disp2pf">pf::disp2pf</a></a></strong><a name="pf::disp2pf"></a> {pfid1 pfid2 args} {
    set pfid1 [CheckPfid $pfid1]
    set pfid2 [CheckPfid $pfid2]
    if {$pfid1 == 0} {
	return -code error &#34;wrong first pf id&#34;
    }
    if {$pfid2 == 0} {
	return -code error &#34;wrong second pf id&#34;
    }
    variable $pfid1
    upvar 0 $pfid1 state1
    variable $pfid2
    upvar 0 $pfid2 state2

    set code [catch {
	StateCheck $pfid1 \
		-dataExist \
		-thdDone
	StateCheck $pfid2 \
		-dataExist \
		-thdDone
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set qLst $state1(q_lst)
    set base1 $state1(baseSigName)
    set base2 $state2(baseSigName)
    set h0 0

    set ish no
    set isa0 no

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set qLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -h {
		set h0 [lindex $args 1]
		set args [lreplace $args 0 1]
		<font color="#208020">#echo $h0</font>
		set ish yes
	    }
	    -a0 {
		set oct [lindex $args 1]
		set voice [lindex $args 2]
		set args [lreplace $args 0 2]
		set isa0 yes
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    <font color="#208020"># create signal h0loga</font>
    set q0 [lindex $qLst 0]
    set q0_str [<a name="get_q_str(39)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q0]
    set a0 [sgetx0 ${base1}_h${q0_str}]
    set da0 [sgetdx ${base1}_h${q0_str}]
    set asize [ssize ${base1}_h${q0_str}]
    set noct $state1(n_octave)
    set nvoice $state1(n_voice)

    if { $isa0 == &#34;yes&#34; } {
	set loga0 [expr $oct*$nvoice+$voice]
	if { ($loga0 &gt;= $asize) || ($loga0&lt;0)} {
	    return -code error &#34;wrong oct and voice&#34;
	} else {
	}
    } else {
	set loga0 0
    }

    <font color="#208020"># Create the list of signals to pass to mdisp command.</font>
    set completeLst {}
    set sigLst {}
    foreach q $qLst {
	set value_lst {}
	set q_str [<a name="get_q_str(40)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	
	<font color="#208020"># on va retrancher hh(a0,q)</font>
	if { $isa0 == &#34;yes&#34;} {
	    set cste1 [lindex [sget ${base1}_h${q_str} $loga0] 0]
	    set cste2 [lindex [sget ${base2}_h${q_str} $loga0] 0]
	} else {
	    set cste1 0
	    set cste2 0
	}
	for {set k 0} { $k &lt; $asize} {incr k} {
	    set hloga_value [expr $h0*($a0+$k*$da0-$loga0*1.0/$nvoice)]
	    lappend value_lst $hloga_value
	}
	screate h0loga $a0 $da0 $value_lst
	
	scomb ${base1}_h${q_str} h0loga x-y-$cste1 ${base1}_h${q_str}_disp2
	set sigLst [lappend sigLst ${base1}_h${q_str}_disp2]
	scomb ${base2}_h${q_str} h0loga x-y-$cste2 ${base2}_h${q_str}_disp2
	set sigLst [lappend sigLst ${base2}_h${q_str}_disp2]
    }

    set completeLst [lappend completeLst ${sigLst}]

    if {[gettype ${base1}_tq] == &#34;S&#34;} {
	lappend completeLst [list ${base1}_hq ]
    }

    set code [catch {mdisp 1 1 ${completeLst}} w]
    if {$code != 0} {
	error $w $w
    }

    ${w} switch_allgraph_flag
    ${w} gr set_disp_mode all
    if {$state1(dimension) == &#34;2D&#34;} {
	set source &#34;image(s)&#34;
    } else {
	set source &#34;signal(s)&#34;
    }
    set a00 [format &#34;%.2f&#34; [expr ($loga0)*1.0/($nvoice)]]

    ${w} setLabel &#34;$state1(comments)\n($state1(a_min), $state1(n_octave), \
	    $state1(n_voice)) ; $state1(n_study) $source\n h0 = $h0 et \
	    a0 = $a00&#34; 4

    $w setColorsByList {red blue red blue red blue red blue}

    set itemList {}
    foreach value $qLst {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $w setLabelsItemsByList $itemList

<font color="#208020">#    ${w}gr0000 set_label {black &#34;Z(a, q), q = &#34;} allSigLabel</font>
<font color="#208020">#    ${w}gr0002 set_label {black &#34;D(a, q), q = &#34;} allSigLabel</font>
    ${w}gr0000 set_label {black &#34;h(a, q) -h0*ln(a) -h(a0,q), q = &#34;} allSigLabel

    ${w} gr init_disp

    ${w} gr set_box_coord 0 5 -1.4 1
    eval ${w} print haq.eps
    return $w
}


<font color="#208020"># pf::integrate_haq --</font>
<font color="#208020"># usage pf::integrate_haq pfId integer integer</font>
<font color="#208020">#</font>
<font color="#208020">#  Compute the integrale value of function h(a,q)</font>
<font color="#208020">#  between a_min and a_max for each value of q.</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId     - The pf id.</font>
<font color="#208020">#   integer  - indice of amin</font>
<font color="#208020">#   integer  - indice of amax</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -qlist : Display only some values of q.</font>
<font color="#208020">#     list - list of the values of q to display. The default is all the values.</font>
<font color="#208020">#   -h     :</font>
<font color="#208020">#</font>

<strong><a name="pf::integrate_haq_2369">proc <a href="partFcts.tcl-annot.html#pf::integrate_haq">pf::integrate_haq</a></a></strong><a name="pf::integrate_haq"></a> {pfid amin amax args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-thdDone
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set qLst $state(q_lst)
    set base $state(baseSigName)
    set integrale_lst {}
    set h0 0
    set ish no
    set isa0 no
    
    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set qLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -h {
		set h0 [lindex $args 1]
		set args [lreplace $args 0 1]
		<font color="#208020">#echo $h0</font>
		set ish yes
	    }
	    -a0 {
		set oct [lindex $args 1]
		set voice [lindex $args 2]
		set args [lreplace $args 0 2]
		set isa0 yes
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    set noct $state(n_octave)
    set nvoice $state(n_voice)
    set q0 [lindex $qLst 0]
    set q0_str [<a name="get_q_str(41)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q0]
    set asize [ssize ${base}_h${q0_str}]

    if { $isa0 == &#34;yes&#34; } {
	set loga0 [expr $oct*$nvoice+$voice]
	if { ($loga0 &gt;= $asize) || ($loga0&lt;0)} {
	    return -code error &#34;wrong oct and voice&#34;
	} else {
	}
    } else {
	set loga0 0
    }
    
    foreach q $qLst {
	set value_lst {}
	set q_str [<a name="get_q_str(42)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set a0 [sgetx0 ${base}_h${q_str}]
	set da0 [sgetdx ${base}_h${q_str}]
	set asize [ssize ${base}_h${q_str}]

	<font color="#208020"># take care sintegrate only sum y_value of signal</font>
	<font color="#208020"># without multiplying by dx !!</font>
		<font color="#208020"># on va retrancher hh(a0,q)</font>
	if { $isa0 == &#34;yes&#34;} {
	    set cste [lindex [sget ${base}_h${q_str} $loga0] 0]
	} else {
	    set cste 0
	}
	for {set k 0} { $k &lt; $asize} {incr k} {
	    set hloga_value [expr $h0*($a0+$k*$da0-$loga0*1.0/$nvoice)+$cste]
	    lappend value_lst $hloga_value
	}
	screate h0loga $a0 $da0 $value_lst
	scomb ${base}_h${q_str} h0loga x-y ${base}_h${q_str}_2

	<font color="#208020">#echo [lindex [sget ${base}_h${q_str}_2 0] 0]</font>

	<font color="#208020"># take care sintegrate sums  y_value of signal (without multiplying</font>
	<font color="#208020"># the result by dx)</font>
	sintegrate ${base}_h${q_str}_2 int_${base}_h${q_str}
	set thevalue [expr [lindex [sget int_${base}_h${q_str} $amax] 0] - [lindex [sget int_${base}_h${q_str} $amin] 0]]
	set thevalue [expr 2*$thevalue/($amax-$amin)/($amax-$amin+1)/$da0]
	lappend integrale_lst $thevalue
    }
    
    foreach q $qLst {
	set q_str [<a name="get_q_str(43)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	delete int_${base}_h${q_str}
    }
<font color="#208020">#    delete thevalue</font>

    return $integrale_lst
}


<font color="#208020"># pf::get_haq_value --</font>
<font color="#208020"># usage pf::get_haq_value pfId integer float</font>
<font color="#208020">#</font>
<font color="#208020">#  Returns the value of function h(a=a0,q=q0)</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId     - The pf id.</font>
<font color="#208020">#   integer  - indice of a0</font>
<font color="#208020">#   float    - value of q0</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#</font>

<strong><a name="pf::get_haq_value_2494">proc <a href="partFcts.tcl-annot.html#pf::get_haq_value">pf::get_haq_value</a></a></strong><a name="pf::get_haq_value"></a> {pfid thea theq args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state
    
    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-thdDone
    } result]
    if {$code == 1} {
	    return -code error $result
	}

    set qLst $state(q_lst)
    set base $state(baseSigName)
    
    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set qLst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    set q_str [<a name="get_q_str(44)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $theq]

    set haq_value [lindex [sget ${base}_h${q_str} $thea] 0]	    	    
    return $haq_value
}
	    

<font color="#208020"># pf::init --</font>
<font color="#208020"># usage pf::init pfId float int int list int string string args</font>
<font color="#208020">#</font>
<font color="#208020">#  Init the parameters of a pf.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   float  - The first scale.</font>
<font color="#208020">#   int    - The number of octaves.</font>
<font color="#208020">#   int    - The number of voice.</font>
<font color="#208020">#   list   - The list of values of q (floats).</font>
<font color="#208020">#   int    - The size of the original data.</font>
<font color="#208020">#   string - The method used to create partition functions data. Must be one of</font>
<font color="#208020">#            the following : &#34;Gradient lines&#34;, &#34;Gradient max&#34;, &#34;Gradient max </font>
<font color="#208020">#            -tag&#34;, &#34;Gradient max - notag&#34;, &#34;Gradient max - theta&#34;, &#34;Mexican&#34;, #            &#34;gauss&#34; or any kind of 1d wavelet.</font>
<font color="#208020">#   string - Comments.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -tsallis    list : init the state variable state(qtsa_lst)</font>
<font color="#208020">#   -turbulence</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::init_2563">proc <a href="partFcts.tcl-annot.html#pf::init">pf::init</a></a></strong><a name="pf::init"></a> {pfid amin noctave nvoice qlst s met comments args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set isTsallis no
    set isTurbulence no

    while {[llength $args] != 0} {
	switch -exact -- [lindex $args 0] {
	    -tsallis {
		set isTsallis yes
		set  qtsalst [lindex $args 1]
		<font color="#208020">#echo $qtsalst</font>
		set args [lreplace $args 0 1]
	    }
	    -turbulence {
		set isTurbulence yes
		set args [lreplace $args 0 0]
	    }
	    default {
		<font color="#208020">#lappend options [lindex $args 0]</font>
		set args [lreplace $args 0 0]
	    }
	}
    }

    if {$state(n_study)  != 0} {
	return -code error \
		&#34;parameters already initialised for this pf id&#34;
    }
    if {$amin &lt; 1} {
	return -code error \
		&#34;bad first scale value&#34;
    }
    if {$noctave &lt; 1} {
	return -code error &#34;bad value of parameter \&#34;noctave\&#34;&#34;
    }
    if {$nvoice &lt; 1} {
	return -code error &#34;bad value of parameter \&#34;nvoice\&#34;&#34;
    }
    if {$s &lt; 1} {
	return -code error &#34;bad value of parameter \&#34;s\&#34;&#34;
    }

    variable allowedMethodsArray
    set str [lrange $met 0 3]
    set elt [array get allowedMethodsArray $str]
    if {$elt == &#34;&#34;} {
	return -code error &#34;bad method&#34;
    }

    set state(a_min)		$amin
    set state(n_octave)		$noctave
    set state(n_voice)		$nvoice
    set state(first_octave)	0
    set state(last_octave)	[expr $noctave-1]
    set state(first_voice)	0
    set state(last_voice)	[expr $nvoice-1]
    set state(q_lst)		$qlst
    set state(size)		$s
    set state(dimension)	[lindex $elt 1]
    set state(study_method)	$met
    set state(comments)		$comments
    if {$isTsallis == &#34;yes&#34;} {
	set state(qtsa_lst) $qtsalst
	<font color="#208020">#echo $state(qtsa_lst)</font>
    }
    if {$isTurbulence == &#34;yes&#34;} {
	<font color="#208020">#echo $state(qturb_lst) </font>
    }
    
    DeletePfSig $pfid

    return
}


<font color="#208020"># pf::OnePf -- PRIVATE</font>
<font color="#208020"># usage pf::onePf pfId str str str str args [-logS str]</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute one partition function from data and add the result to a pf. This</font>
<font color="#208020"># command creates a signal for each value of q. The mathematical expression is</font>
<font color="#208020"># computed for each point of one scale, then we summ all the points. This gives</font>
<font color="#208020"># one point of the signal. This computation is add to the current values of</font>
<font color="#208020"># the signal.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   string - Base name of the source object (signals, images or ext images)</font>
<font color="#208020">#            that contains the data.</font>
<font color="#208020">#   string - Mathematical expression (a la defunc) of the function to apply to</font>
<font color="#208020">#            data at one scale. </font>
<font color="#208020">#   string - Name that identifies this expression (function). Example : STq,</font>
<font color="#208020">#            STqlogT, ...</font>
<font color="#208020">#   args   - Additionnal options to pass to the command (sfct, ...).</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -logS : Compute an other signal with the log of the sum before adding it to</font>
<font color="#208020">#           the current values of the signal. With this option one can compute</font>
<font color="#208020">#           STq and logSTq at the same time.</font>
<font color="#208020">#     string - Name that identifies this 2nd function. Example : logSTq.</font>
<font color="#208020">#   -turbulence</font>
<font color="#208020">#   -firstsid [d] : see &#34;pf compute&#34; command...</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::OnePf_2674">proc <a href="partFcts.tcl-annot.html#pf::OnePf">pf::OnePf</a></a></strong><a name="pf::OnePf"></a> {pfid sourceBaseName mathExpr fctName args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state


    <a name="dputs(1)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;one pf $args&#34;


    set isLogS 0
    set options &#34;&#34;
    set isTurbulence no
    set firstSid 0
    set lastSid [expr {  $state(n_octave)* $state(n_voice) }]


    while {[llength $args] != 0} {
	switch -exact -- [lindex $args 0] {
	    -logS {
		set isLogS 1
		set logFctName [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -turbulence {
	    	set isTurbulence yes
		set args [lreplace $args 0 0]
	    }
	    -firstsid {
		set firstSid [lindex $args 1]
		set args [lreplace $args 0 1]
		<a name="dputs(2)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;onepf firstsid $firstSid&#34;
	    }
	    default {
		lappend options [lindex $args 0]
		set args [lreplace $args 0 0]
	    }
	}
    }
    set zeId [format &#34;%.3d&#34; $firstSid]
    <a name="dputs(3)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;zeId $zeId $options&#34;
    switch [gettype ${sourceBaseName}${zeId}] {
	S {
	    set cmdName sfct
	}
	I {
	    set cmdName ifct
	}
	E {
	    set cmdName efct
	}
	default {
	    return -code error &#34;wrong data object&#34;
	}
    }



    if {$isTurbulence == &#34;yes&#34;} {
	set the_q_liste $state(qturb_lst)
	<font color="#208020">#echo $the_q_liste</font>
    } else {
	set the_q_liste $state(q_lst)
    }

    foreach q $the_q_liste {
	set q_str [<a name="get_q_str(45)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	
	<font color="#208020">#dputs &#34;$cmdName : q $q&#34;</font>
	
        catch {unset theList}
	set memSid 0
	for { set oct 0;set num 0} { $oct &lt; $state(n_octave)} { incr oct } {
	    for {set vox 0} { $vox &lt; $state(n_voice) } { incr vox ; incr num; incr memSid} {
		if {$memSid &lt; $firstSid || $memSid &gt; $lastSid} {
		    continue
		}
		set new_num [format &#34;%.3d&#34; $num]
		<font color="#208020">#dputs &#34;$cmdName : q $q ${new_num}&#34;</font>
		set theVal [eval $cmdName ${sourceBaseName}${new_num} $mathExpr $q $options]
		lappend theList $theVal
		if {$isTurbulence == &#34;yes&#34; &amp;&amp; $q == 0} {
			<font color="#208020">#dputs &#34;$cmdName ${sourceBaseName}${new_num} $mathExpr $q $options $theVal&#34;</font>
		}
	    }
	}

	<font color="#208020"># Add the lists to signal.</font>
	set base $state(baseSigName)

	<font color="#208020"># fctName is either STq or STqlogT </font>
	set sigName ${base}_${fctName}_$q_str 
	if {[string compare [gettype $sigName] S]} {
	    screate $sigName 0 [expr 1.0/$state(n_voice)] $theList
	} else {
	    screate __tmp 0 [expr 1.0/$state(n_voice)] $theList
	    sadd $sigName __tmp $sigName
	}

	if {$isLogS} {
	    set sigName ${base}_${logFctName}_$q_str
	    set theList2 &#34;&#34;
	    <font color="#208020">#dputs &#34;thelist $theList&#34;</font>
	    foreach val $theList {
		lappend theList2 [expr ($val?log($val):0)]
	    }
	    if {[string compare [gettype $sigName] S]} {
		screate $sigName 0 [expr 1.0/$state(n_voice)] $theList2
	    } else {
		screate __tmp 0 [expr 1.0/$state(n_voice)] $theList2
		sadd $sigName __tmp $sigName
	    }
	}

	catch {delete __tmp}
    }

<font color="#208020">#    if {$isTurbulence == &#34;yes&#34;} {</font>
<font color="#208020">#	set base $state(baseSigName)</font>
<font color="#208020">#	set q0_str [get_q_str 0]</font>
<font color="#208020">#	set sigName0 ${base}_${fctName}_$q0_str</font>
<font color="#208020">#	foreach q {1 2 3} {</font>
<font color="#208020">#	    set q_str [get_q_str $q]</font>
<font color="#208020">#	    set sigName ${base}_${fctName}_$q_str</font>
<font color="#208020">#	    scomb $sigName0 $sigName y/x $sigName</font>
<font color="#208020">#	}</font>
<font color="#208020">#    }</font>
    

}


<font color="#208020">## ATTENTION</font>
<font color="#208020"># il y a des trucs pas tres propres dans tout ce qui suit!!!</font>
<font color="#208020"># en particulier l'option -SK_logT qui est passe en option a</font>
<font color="#208020"># la commande efct_tsallis, et qui sert au calcul des signaux</font>
<font color="#208020"># SKqqtsa_logT, qui est le denominateur de l'energie de tsallis.</font>


<font color="#208020"># pf::OnePf_tsallis -- PRIVATE</font>
<font color="#208020"># usage pf::onePf_tsallis pfId str str str str args [-logS str]</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute one tsallis partition function from data and add the result</font>
<font color="#208020"># to a pf. This command creates a signal for each value of q (temperature)</font>
<font color="#208020"># and qtsa (tsallis parameter). The mathematical expression is</font>
<font color="#208020"># computed for each point of one scale, then we summ all the points. This gives</font>
<font color="#208020"># one point of the signal. This computation is add to the current values of</font>
<font color="#208020"># the signal.</font>
<font color="#208020">#</font>
<font color="#208020"># TAKE CARE THAT :</font>
<font color="#208020"># As for now, this is ONLY for partition functions on WTMMM.!!!</font>
<font color="#208020"># This routine is called by pf::compute.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   string - Base name of the source object (signals, images or ext images)</font>
<font color="#208020">#            that contains the data.</font>
<font color="#208020">#   string - First  Mathematical expression (a la defunc).</font>
<font color="#208020">#   string - Second Mathematical expression (a la defunc). </font>
<font color="#208020">#   string - Name that identifies this expression (function). Example :</font>
<font color="#208020">#            SKqqtsa, SKqqtsa_logT, SLqqtsa ...</font>
<font color="#208020">#   args   - Additionnal options to pass to the command (efct_tsallis, ...).</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -logS : Compute an other signal with the log of the sum before adding it to</font>
<font color="#208020">#           the current values of the signal. With this option one can compute</font>
<font color="#208020">#           SLqqtsa and logSLqqtsa at the same time.</font>
<font color="#208020">#     string - Name that identifies this 2nd function. Example : logSLqqtsa.</font>
<font color="#208020">#  -SK_logT : option to append to efct_tsallis command.</font>
<font color="#208020">#</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::OnePf_tsallis_2850">proc <a href="partFcts.tcl-annot.html#pf::OnePf_tsallis">pf::OnePf_tsallis</a></a></strong><a name="pf::OnePf_tsallis"></a> {pfid sourceBaseName mathExpr1 mathExpr2 fctName args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    switch [gettype ${sourceBaseName}000] {
	S {
	    set cmdName sfct
	}
	I {
	    set cmdName ifct
	}
	E {
	    set cmdName efct_tsallis
	}
	default {
	    return -code error &#34;wrong data object&#34;
	}
    }

    <font color="#208020">#echo toto</font>
    set isLogS 0
    set options &#34;&#34;
    while {[llength $args] != 0} {
	switch -exact -- [lindex $args 0] {
	    -logS {
		set isLogS 1
		set logFctName [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	     -SK_logT {
		lappend options -SK_logT
		set args [lreplace $args 0 0]
	    }
	    default {
		lappend options [lindex $args 0]
		set args [lreplace $args 0 0]
	    }
	}
    }

    <font color="#208020">#echo $options</font>

    foreach q $state(q_lst) {
	set q_str [<a name="get_q_str(46)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	<font color="#208020">#echo q $q</font>
	foreach qtsa $state(qtsa_lst) {
	    set qtsa_str [<a name="get_q_str(47)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]

	    <font color="#208020">#echo $cmdName</font>
	    catch {unset theList}
	    <font color="#208020"># scale's loop to compute signal values</font>
	    for { set oct 0;set num 0}\
		    { $oct &lt; $state(n_octave)} \
		    { incr oct } {
		for {set vox 0} \
			{ $vox &lt; $state(n_voice) } \
			{ incr vox ; incr num} {
		    set new_num [format &#34;%.3d&#34; $num]
		    set theVal [eval $cmdName ${sourceBaseName}${new_num} $mathExpr1 $mathExpr2 $q $qtsa $options]
		    <font color="#208020">#echo $theVal</font>
		    lappend theList $theVal
		}
	    }
	    <font color="#208020">#echo toto $theList</font>

	    <font color="#208020"># Add the lists to signal.</font>
	    <font color="#208020">#</font>
	    
	    set base $state(baseSigName)
	    <font color="#208020"># example of a valid base : _pf1</font>

	    <font color="#208020"># we create signal; fctname := SKqqtsa for example.</font>
	    set sigName ${base}_${fctName}_${q_str}_${qtsa_str}
	    
	    if {[string compare [gettype $sigName] S]} {
		screate $sigName 0 [expr 1.0/$state(n_voice)] $theList
	    } else {
		screate __tmp 0 [expr 1.0/$state(n_voice)] $theList
		sadd $sigName __tmp $sigName
	    }
	    
	    if {$isLogS} {
		set sigName ${base}_${logFctName}_$q_str
		set theList2 &#34;&#34;
		foreach val $theList {
		    lappend theList2 [expr ($val?log($val):0)]
		}
		if {[string compare [gettype $sigName] S]} {
		    screate $sigName 0 [expr 1.0/$state(n_voice)] $theList2
		} else {
		    screate __tmp 0 [expr 1.0/$state(n_voice)] $theList2
		    sadd $sigName __tmp $sigName
		}
	    }
	    
	    catch {delete __tmp}
	}
    }
}


<font color="#208020"># pf::compute --</font>
<font color="#208020"># usage pf::compute pfId str</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the partition functions from data and add the result to a pf.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   string - Base name of the source object (signals, images or ext images) that</font>
<font color="#208020">#            contains the data.</font>
<font color="#208020">#   options :</font>
<font color="#208020">#     -domain [dddd] : use only maxima that are inside a given domain</font>
<font color="#208020">#                      (specified as in ecut command).</font>
<font color="#208020">#     -tsallis       : compute tsallis partition functions.</font>
<font color="#208020">#     -turbulence    : compute cumulants partition functions.</font>
<font color="#208020">#     -firstsid [d]  : to specify the scale at which we start computations</font>
<font color="#208020">#                      (see same option in &#34;chain&#34; command).</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The number of studies.</font>
<font color="#208020">#</font>
<font color="#208020"># modified by pierre kestener on 12 feb 2001</font>
<font color="#208020"># option -domain [dddd]</font>
<font color="#208020">#</font>
<font color="#208020"># modified by pierre kestener on 21 mar 2001</font>
<font color="#208020"># option -tsallis</font>
<font color="#208020"># abandoned !</font>
<font color="#208020">#</font>
<font color="#208020"># modified by pierre kestener on 07 nov 2001</font>
<font color="#208020"># option -turbulence</font>
<font color="#208020"># abandoned !</font>
<font color="#208020">#</font>
<font color="#208020"># modified by PK (21/04/2006)</font>
<font color="#208020"># option -mask [I]</font>
<font color="#208020">#</font>

<strong><a name="pf::compute_2990">proc <a href="partFcts.tcl-annot.html#pf::compute">pf::compute</a></a></strong><a name="pf::compute"></a> {pfid sourceBaseName args} {

    <font color="#208020"># exemple : pfid           -&gt; ::pf::1</font>
    <font color="#208020">#         : sourceBaseName -&gt; m</font>
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set istsallis no
    set isTurbulence no
    set firstSid 0

    set options &#34;&#34;
    while {[llength $args] != 0} {
	switch -exact -- [lindex $args 0] {
	    -domain {
		lappend options -domain
		set x1 [lindex $args 1]
		set y1 [lindex $args 2]
		set x2 [lindex $args 3]
		set y2 [lindex $args 4]
		lappend options $x1 $y1 $x2 $y2
		set args [lreplace $args 0 4]
	    }
	    -mask {
		lappend options -mask
		set mask [lindex $args 1]
		lappend options $mask
		set args [lreplace $args 0 1]
	    }
	    -tsallis {
	    	set istsallis yes
	    	set args [lreplace $args 0 0]
	    }
	    -turbulence {
	    	set isTurbulence yes
		set args [lreplace $args 0 0]
	    }
	    -dx {
		lappend options &#34;-dx&#34;
		set args [lreplace $args 0 0]
	    }
	    -dy {
		lappend options &#34;-dy&#34;
		set args [lreplace $args 0 0]
	    }
	    -firstsid {
		set firstSid [lindex $args 1]
		set args [lreplace $args 0 1]
		lappend options &#34;-firstsid&#34;
		lappend options &#34;$firstSid&#34;
		<font color="#208020">#dputs &#34;compute firstsid $firstSid&#34;</font>
	    }
	    default {
		set args [lreplace $args 0 0]
	    }
	}
    }
    
    switch -glob $state(study_method) {
	{Gradient max} {
	    lappend options &#34;-vc&#34;
	}
	{Gradient max - tag} {
	    lappend options -vc -tag
	}
	{Gradient max - notag} {
	    lappend options -vc -notag
	}
	{Gradient max - theta * dtheta *} {
	    set theta  [lindex $state(study_method) 4]
	    set dTheta [lindex $state(study_method) 6]
	    set pi [expr { acos(-1) }]
	    set simil [expr 1-$dTheta/(2*$pi)]
	    lappend options -vc -arg $theta $simil
	}
	{Mexican} {
	    lappend options &#34;-vc&#34;
	}
    }
    
    if { $istsallis == &#34;yes&#34; } {
	eval OnePf_tsallis $pfid $sourceBaseName x*log(abs(y)) \
		(1+(1-x)*y)^(x/(1-x)) SKqqtsa $options -logS logSKqqtsa
	eval OnePf_tsallis $pfid $sourceBaseName  x*log(abs(y)) \
		(1+(1-x)*y)^(x/(1-x)) SKqqtsalogT -SK_logT $options
	eval OnePf_tsallis $pfid $sourceBaseName x*log(abs(y)) \
		(1+(1-x)*y)^(1/(1-x)) SLqqtsa $options
    } else {
	<font color="#208020">#eval OnePf $pfid $sourceBaseName exp(y*log(abs(x))) \</font>
	<font color="#208020">#	STq $options -logS logSTq</font>
	eval OnePf $pfid $sourceBaseName (abs(x))^y \
		STq $options -logS logSTq
	<font color="#208020"># abs(x)^y means (wavelet_modulus)^q.</font>
	eval OnePf $pfid $sourceBaseName log(abs(x))*(abs(x))^y \
		STqlogT $options
	<font color="#208020"># log(abs(x))*abs(x)^y means (wavelet_modulus)^q*log(wtm).</font>
	if {$isTurbulence == &#34;yes&#34;} {
	    <font color="#208020">#eval OnePf $pfid $sourceBaseName exp(y*log(log(abs(x))/log(2))) \</font>
	    <font color="#208020">#	    SlogTq -turbulence $options </font>
	    eval OnePf $pfid $sourceBaseName (log(abs(x))/log(2))^y \
		    SlogTq -turbulence $options 
	    <font color="#208020"># (log(abs(x)))^y means (log of wavelet_modulus)^q.</font>
	}
    }
    incr state(n_study)
}


<font color="#208020"># pf::save --</font>
<font color="#208020"># usage pf::save pfId str args</font>
<font color="#208020">#</font>
<font color="#208020">#   Save the partition functions.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   string - File name.</font>
<font color="#208020">#</font>
<font color="#208020">#   options :</font>
<font color="#208020">#     -tsallis</font>
<font color="#208020">#     -turbulence</font>
<font color="#208020">#     -nstudy</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::save_3119">proc <a href="partFcts.tcl-annot.html#pf::save">pf::save</a></a></strong><a name="pf::save"></a> {pfid name args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    <font color="#208020"># Options analysis.</font>
    set isTsallis no
    set isTurbulence no
    set isNstudy no

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -tsallis {
		set isTsallis yes
		set qtsa [lindex $args 1]
		set args [lreplace $args 0 1]
		set qtsa_str [<a name="get_q_str(48)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]
	    }
	    -turbulence {
		set isTurbulence yes
		set args [lreplace $args 0 0]
	    }
	    -nstudy {
		set isNstudy yes
		set args [lreplace $args 0 0]
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    if {[file exists $name]} {
	file rename -force $name $name.bak
    }

    set file [open $name w]

    if {$isTsallis == &#34;yes&#34;} {
	puts $file &#34;Tsallis Partition function&#34;
    } else {
	puts $file &#34;Partition function&#34;
    }
    puts $file &#34;First scale : $state(a_min)&#34;
    puts $file &#34;Number of octaves : $state(n_octave)&#34;
    puts $file &#34;Number of voices : $state(n_voice)&#34;
    puts $file &#34;First octave : $state(first_octave)&#34;
    puts $file &#34;Last octave : $state(last_octave)&#34;
    puts $file &#34;First voice : $state(first_voice)&#34;
    puts $file &#34;Last voice : $state(last_voice)&#34;
    puts $file &#34;Sources size : $state(size)&#34;
    if {$isNstudy == &#34;yes&#34;} {
	puts $file &#34;Number of sources : 1&#34;
    } else {
	puts $file &#34;Number of sources : $state(n_study)&#34;
    }
    puts $file &#34;Source dimension : $state(dimension)&#34;
    puts $file &#34;Method : $state(study_method)&#34;
    puts $file &#34;List of values of q : $state(q_lst)&#34;
    if {$isTsallis == &#34;yes&#34;} {
	puts $file &#34;Tsallis parameter qtsa : $qtsa&#34;
    }
    


    set base $state(baseSigName)

    if {$isTsallis == &#34;yes&#34;} {
	foreach q $state(q_lst) {
	    set q_str [<a name="get_q_str(49)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    puts $file &#34;q : $q&#34;
	    puts $file &#34;SKqqtsa : [sgetlst ${base}_SKqqtsa_${q_str}_${qtsa_str}]&#34;
	    puts $file &#34;SKqqtsalogT : [sgetlst ${base}_SKqqtsalogT_${q_str}_${qtsa_str}]&#34;
	    puts $file &#34;SLqqtsa : [sgetlst ${base}_SLqqtsa_${q_str}_${qtsa_str}]&#34;
	}
    } else {
	foreach q $state(q_lst) {
	    set q_str [<a name="get_q_str(50)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    puts $file &#34;q : $q&#34;
	    puts $file &#34;STq : [sgetlst ${base}_STq_${q_str}]&#34;
	    puts $file &#34;logSTq : [sgetlst ${base}_logSTq_${q_str}]&#34;
	    puts $file &#34;STqlogT : [sgetlst ${base}_STqlogT_${q_str}]&#34;
	}
	if {$isTurbulence == &#34;yes&#34;} {
	    foreach q $state(qturb_lst) {
		set q_str [<a name="get_q_str(51)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
		puts $file &#34;q : $q&#34;
		puts $file &#34;SlogTq : [sgetlst ${base}_SlogTq_${q_str}]&#34;
	    }
	}
    }
    puts $file &#34;Comments :\n$state(comments)&#34;
    close $file
}


<font color="#208020"># pf::load --</font>
<font color="#208020"># usage pf::load pfId str</font>
<font color="#208020">#</font>
<font color="#208020">#   Load the partition functions.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   string - File name.</font>
<font color="#208020">#</font>
<font color="#208020">#   options :</font>
<font color="#208020">#     -turbulence</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::load_3233">proc <a href="partFcts.tcl-annot.html#pf::load">pf::load</a></a></strong><a name="pf::load"></a> {pfid name args} {
    <font color="#208020"># Command to rewrite to handle file format problems.</font>

    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    <font color="#208020"># Options analysis.</font>

    set isForce no
    set isTurbulence no

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -force {
		set isForce yes
		set args [lreplace $args 0 0]
	    }
	    -turbulence {
		set isTurbulence yes
		set args [lreplace $args 0 0]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    set base $state(baseSigName)

    set file [open $name r]
    if {$state(n_study) == 0} { <font color="#208020"># Create new values.</font>
	gets $file l
	if {[string compare $l &#34;Partition function&#34;] != 0} {
	    return -code error &#34;wrong file format&#34;
	}
	set state(a_min)        [lindex [gets $file] end]
	set state(n_octave)     [lindex [gets $file] end]
	set state(n_voice)      [lindex [gets $file] end]
	set state(first_octave) [lindex [gets $file] end]
	set state(last_octave)  [lindex [gets $file] end]
	set state(first_voice)  [lindex [gets $file] end]
	set state(last_voice)   [lindex [gets $file] end]
	set state(size)         [lindex [gets $file] end]
	set state(n_study)      [lindex [gets $file] end]
	set state(dimension)    [lindex [gets $file] end]
	set state(study_method) [lrange [gets $file] 2 end]
	set state(q_lst)        [lrange [gets $file] 6 end]
	set state(qturb_lst)    {0 1 2 3}

	foreach q $state(q_lst) {
	    set q_str [<a name="get_q_str(52)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    gets $file
	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate ${base}_STq_${q_str} 0 [expr 1.0/$state(n_voice)] $val_lst
	    scomb ${base}_STq_${q_str} ${base}_STq_${q_str} x*x ${base}_STq2_${q_str}

	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate ${base}_logSTq_${q_str} 0 [expr 1.0/$state(n_voice)] $val_lst
	    scomb ${base}_logSTq_${q_str} ${base}_logSTq_${q_str} x*x ${base}_logSTq2_${q_str}

	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate ${base}_STqlogT_${q_str} 0 [expr 1.0/$state(n_voice)] $val_lst
	    scomb ${base}_STqlogT_${q_str} ${base}_STqlogT_${q_str} x*x ${base}_STqlogT2_${q_str}	    

	}
	if {$isTurbulence == &#34;yes&#34;} {
	    foreach q $state(qturb_lst) {
		gets $file
		set q_str [<a name="get_q_str(53)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
		set val_lst [lrange [gets $file] 2 end]
		regsub -all {\+\+} $val_lst 0 val_lst
		regsub -all {\-\-\-} $val_lst 0 val_lst
		screate ${base}_SlogTq_${q_str} 0 [expr 1.0/$state(n_voice)] $val_lst
	    }
	}

	gets $file
	gets $file comments
	while {[gets $file str] != -1} {
	    set state(comments) &#34;$comments\n$str&#34;
	}
	close $file
    } else { <font color="#208020"># Add the new values.</font>
	gets $file
	if {$state(a_min)    != [lindex [gets $file] end]} {return -code error &#34;Bad value&#34;}
	if {$state(n_octave) != [lindex [gets $file] end]} {return -code error &#34;Bad value&#34;}
	if {$state(n_voice)  != [lindex [gets $file] end]} {return -code error &#34;Bad value&#34;}

	<font color="#208020"># !!!! ATTENTION -&gt; METTRE A JOUR CES VALEURS !!!!!!!!!!!</font>
	set new_first_octave [lindex [gets $file] end]
	set new_last_octave  [lindex [gets $file] end]
	set new_first_voice  [lindex [gets $file] end]
	set new_last_voice   [lindex [gets $file] end]
	
	if {$state(size) != [lindex [gets $file] end]} {return -code error &#34;Bad value&#34;}
	
	incr state(n_study) [lindex [gets $file] end]
	
	if {[string compare $state(dimension) [lindex [gets $file] end]] != 0} {return -code error &#34;Bad value&#34;}
	if {$isForce == &#34;no&#34;} {
	    if {[string compare $state(study_method) [lrange [gets $file] 2 end]] != 0} {return -code error &#34;Bad value for method&#34;}
	} else {
	    gets $file
	}
	if {[string compare $state(q_lst) [lrange [gets $file] 6 end]] != 0} {return -code error &#34;Bad value for q list&#34;}
	
	foreach q $state(q_lst) {
	    set q_str [<a name="get_q_str(54)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    gets $file

	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate __tmp 0 [expr 1.0/$state(n_voice)] $val_lst
	    scomb __tmp __tmp x*x __tmp2
	    sadd ${base}_STq_${q_str} __tmp ${base}_STq_${q_str}
	    sadd ${base}_STq2_${q_str} __tmp2 ${base}_STq2_${q_str}
	    
	    
	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate __tmp 0 [expr 1.0/$state(n_voice)] $val_lst
	    scomb __tmp __tmp x*x __tmp2
	    sadd ${base}_logSTq_${q_str} __tmp ${base}_logSTq_${q_str}
	    sadd ${base}_logSTq2_${q_str} __tmp2 ${base}_logSTq2_${q_str}

	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate __tmp 0 [expr 1.0/$state(n_voice)] $val_lst
	    scomb __tmp __tmp x*x __tmp2
	    sadd ${base}_STqlogT_${q_str} __tmp ${base}_STqlogT_${q_str}
	    sadd ${base}_STqlogT2_${q_str} __tmp2 ${base}_STqlogT2_${q_str}
	}
	if {$isTurbulence == &#34;yes&#34;} {
	    foreach q $state(qturb_lst) {
		gets $file
		set q_str [<a name="get_q_str(55)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
		set val_lst [lrange [gets $file] 2 end]
		regsub -all {\+\+} $val_lst 0 val_lst
		regsub -all {\-\-\-} $val_lst 0 val_lst
		screate __tmp 0 [expr 1.0/$state(n_voice)] $val_lst
		sadd ${base}_SlogTq_${q_str} __tmp ${base}_SlogTq_${q_str}
		}
	}

	catch {delete __tmp __tmp2}
	close $file
    }
}


<font color="#208020"># pf::load_tsallis --</font>
<font color="#208020"># usage pf::load_tsallis pfId str real</font>
<font color="#208020">#</font>
<font color="#208020">#   Load a Tsallis partition functions for a given value</font>
<font color="#208020">#   of tsallis parameter.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - The pf id.</font>
<font color="#208020">#   string - File name.</font>
<font color="#208020">#   real   - value of tsallis parameter</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::load_tsallis_3414">proc <a href="partFcts.tcl-annot.html#pf::load_tsallis">pf::load_tsallis</a></a></strong><a name="pf::load_tsallis"></a> {pfid name qtsa args} {
    <font color="#208020"># Command to rewrite to handle file format problems.</font>

    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    <font color="#208020"># Options analysis.</font>

    set isForce no

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -force {
		set isForce yes
		set args [lreplace $args 0 0]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    set base $state(baseSigName)
    set qtsa_str [<a name="get_q_str(56)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]

    set file [open $name r]
    if {$state(n_study) == 0} { <font color="#208020"># Create new values.</font>
	gets $file l
	if {[string compare $l &#34;Tsallis Partition function&#34;] != 0} {
	    return -code error &#34;wrong file format&#34;
	}
	set state(a_min)        [lindex [gets $file] end]
	set state(n_octave)     [lindex [gets $file] end]
	set state(n_voice)      [lindex [gets $file] end]
	set state(first_octave) [lindex [gets $file] end]
	set state(last_octave)  [lindex [gets $file] end]
	set state(first_voice)  [lindex [gets $file] end]
	set state(last_voice)   [lindex [gets $file] end]
	set state(size)         [lindex [gets $file] end]
	set state(n_study)      [lindex [gets $file] end]
	set state(dimension)    [lindex [gets $file] end]
	set state(study_method) [lrange [gets $file] 2 end]
	set state(q_lst)        [lrange [gets $file] 6 end]
	set qtsafile            [lindex [gets $file] end]
	if {$qtsa != $qtsafile} {
	    return -code error &#34;given tsallis parameter is different from the one inside file&#34;
	}
	

	foreach q $state(q_lst) {
	    set q_str [<a name="get_q_str(57)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    gets $file
	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate ${base}_SKqqtsa_${q_str}_${qtsa_str} 0 [expr 1.0/$state(n_voice)] $val_lst
	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate ${base}_SKqqtsalogT_${q_str}_${qtsa_str} 0 [expr 1.0/$state(n_voice)] $val_lst
	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate ${base}_SLqqtsa_${q_str}_${qtsa_str} 0 [expr 1.0/$state(n_voice)] $val_lst
	}

	gets $file
	gets $file comments
	while {[gets $file str] != -1} {
	    set state(comments) &#34;$comments\n$str&#34;
	}
	close $file
    } else { <font color="#208020"># Add the new values.</font>
	gets $file
	if {$state(a_min)    != [lindex [gets $file] end]} {return -code error &#34;Bad value&#34;}
	if {$state(n_octave) != [lindex [gets $file] end]} {return -code error &#34;Bad value&#34;}
	if {$state(n_voice)  != [lindex [gets $file] end]} {return -code error &#34;Bad value&#34;}

	<font color="#208020"># !!!! ATTENTION -&gt; METTRE A JOUR CES VALEURS !!!!!!!!!!!</font>
	set new_first_octave [lindex [gets $file] end]
	set new_last_octave  [lindex [gets $file] end]
	set new_first_voice  [lindex [gets $file] end]
	set new_last_voice   [lindex [gets $file] end]
	
	if {$state(size) != [lindex [gets $file] end]} {return -code error &#34;Bad value&#34;}
	
	incr state(n_study) [lindex [gets $file] end]
	
	if {[string compare $state(dimension) [lindex [gets $file] end]] != 0} {return -code error &#34;Bad value&#34;}
	if {$isForce == &#34;no&#34;} {
	    if {[string compare $state(study_method) [lrange [gets $file] 2 end]] != 0} {return -code error &#34;Bad value for method&#34;}
	} else {
	    gets $file
	}
	if {[string compare $state(q_lst) [lrange [gets $file] 6 end]] != 0} {return -code error &#34;Bad value for q list&#34;}
	if {[string compare $qtsa [lindex [gets $file] end]] != 0} {return -code error &#34;Bad value for qTsallis&#34;}

	foreach q $state(q_lst) {
	    set q_str [<a name="get_q_str(58)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    gets $file

	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate __tmp 0 [expr 1.0/$state(n_voice)] $val_lst
	    sadd ${base}_SKqqtsa_${q_str}_${qtsa_str} __tmp ${base}_SKqqtsa_${q_str}_${qtsa_str}
	    
	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate __tmp 0 [expr 1.0/$state(n_voice)] $val_lst
	    sadd ${base}_SKqqtsalogT_${q_str}_${qtsa_str} __tmp ${base}_SKqqtsalogT_${q_str}_${qtsa_str}

	    set val_lst [lrange [gets $file] 2 end]
	    regsub -all {\+\+} $val_lst 0 val_lst
	    regsub -all {\-\-\-} $val_lst 0 val_lst
	    screate __tmp 0 [expr 1.0/$state(n_voice)] $val_lst
	    sadd ${base}_SLqqtsa_${q_str}_${qtsa_str} __tmp ${base}_SLqqtsa_${q_str}_${qtsa_str}
	}
	catch {delete __tmp}
	close $file
    }
}


<font color="#208020"># pf::localfit --</font>
<font color="#208020"># usage : pf::localfit pfId str [-prefscales real real] [-qlist list]</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute different local linear regression of the partition functions</font>
<font color="#208020"># ``name'' of order q. Take windows of size 1/2, 1, 1.5 and 2 dyades.</font>
<font color="#208020"># create the signals :</font>
<font color="#208020">#    best: the best slope.</font>
<font color="#208020">#    mean: the mean slope.</font>
<font color="#208020">#    min : the min slope</font>
<font color="#208020">#    max : the max slope</font>
<font color="#208020">#    [pref: the prefered slope] </font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId     - The pf id.</font>
<font color="#208020">#   str      - Name of the partition functions (i.e. tau, h or D)</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -qlist : Display only some values of q.</font>
<font color="#208020">#   list  - List of the q values</font>
<font color="#208020">#   -prefscales : Defines prefered bounds for scales.</font>
<font color="#208020">#     real - Prefered value of the minimum scale </font>
<font color="#208020">#     real - Prefered value of the maximum scale</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The list of the name of the 5 created signals.</font>

<strong><a name="pf::localfit_3573">proc <a href="partFcts.tcl-annot.html#pf::localfit">pf::localfit</a></a></strong><a name="pf::localfit"></a> {pfid name args} { 
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-thdDone
    } result]
    if {$code == 1} {
	return -code error $result
    }

    <font color="#208020"># Options analysis.</font>

    set prefamin &#34;&#34;
    set prefamax &#34;&#34;
    set q_lst $state(q_lst)

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -qlist {
		set q_lst [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -prefscales {
		set prefamin [lindex $args 1]
		set prefamax [lindex $args 2]
		set args [lreplace $args 0 2]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    set basename $state(baseSigName)

    catch {unset fit_lst}
    catch {unset meanfit_lst}
    catch {unset bestfit_lst}
    catch {unset amin_bestfit_lst}
    catch {unset amax_bestfit_lst}
    catch {unset amax_fitmax_lst}
    catch {unset amin_fitmax_lst}
    catch {unset amax_fitmin_lst}
    catch {unset amin_fitmin_lst}
    if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	catch {unset preffit_lst}
    }
    foreach q $q_lst {
	set chi 100.0
	set ss 0.0
	set meantot 0.0
	set q_str [<a name="get_q_str(59)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set num [ssize ${basename}_${name}$q_str]
	set x0 [sgetx0 ${basename}_${name}$q_str]
	set dx [sgetdx ${basename}_${name}$q_str]
	set WindLst {5 10 15 20}
	if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	    set newwind [expr $prefamax-$prefamin]
	    set newwind [expr $newwind/$dx]
	    set testwind 0
	    foreach wind $WindLst {
		if {$newwind == $wind} {
		    set testwind 1
		}
	    }
	    if {$testwind == 0} {
		lappend WindLst $newwind
	    }
	}
	foreach wind $WindLst {
	    catch {unset fit_lst}
	    catch {unset x_lst}
	    if {$wind == 20} {
		catch {unset aminfit_lst}
		catch {unset amaxfit_lst}
	    }
	    set numb [expr $num-$wind]
	    for {set i 0} {$i &lt;= $numb} {incr i} {
		set amin [expr $x0+$dx*$i]
		set amax [expr $amin+$wind*$dx]
		set posx [expr ($amin+$amax)/2.0]
		set fit [sfit ${basename}_${name}$q_str $amin $amax]
		set a [lindex $fit 0]
		if {![string compare $a nan]} {
		    set a 0
		}
		lappend fit_lst $a
		lappend x_lst $posx
		if {$amin == $prefamin &amp;&amp; $amax == $prefamax} {
		    set preffit $a
		}
		if {$wind == 20} {
		    set chi2 [lindex $fit 4]
		    if {$chi2 &lt;= $chi} {
			set chi $chi2
			set besta $a
			set bestamax $amax
			set bestamin $amin
		    }
		    lappend aminfit_lst $amin
		    lappend amaxfit_lst $amax
		}
	    }
	    if {$wind == 20} {
		lappend bestfit_lst $besta
		lappend amax_bestfit_lst $bestamax
		lappend amin_bestfit_lst $bestamin
		screate amin_temp [lindex $x_lst 0] $dx $aminfit_lst
		screate amax_temp [lindex $x_lst 0] $dx $amaxfit_lst
	    }
	    screate ${basename}_${name}_wind${wind} [lindex $x_lst 0] $dx $fit_lst 
	    set meanvar [<a name="sstats(1)"><a href="./histogram.tcl.html#sstats_623">sstats</a></a> ${basename}_${name}_wind${wind} 2]
	    set size [ssize ${basename}_${name}_wind${wind}]
	    set mean [lindex $meanvar 0]
	    set meantot [expr $meantot+$size*$mean]
	    set ss [expr $ss+$size]
	}
	set meantot [expr $meantot/$ss]
	set fit [sgetextr ${basename}_${name}_wind20]
	set fitmin [lindex $fit 0]
	set fitmax [lindex $fit 1]
	set iminfit [lindex $fit 2]
	set imaxfit [lindex $fit 3]
	lappend meanfit_lst $meantot
	lappend minfit_lst $fitmin
	lappend maxfit_lst $fitmax	
	if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	    lappend preffit_lst $preffit
	}
	set temp [sget amin_temp $iminfit]
	set amin_fitmin [lindex $temp 0]
	set temp [sget amax_temp $iminfit]
	set amax_fitmin [lindex $temp 0]
	set temp [sget amin_temp $imaxfit]
	set amin_fitmax [lindex $temp 0]
	set temp [sget amax_temp $imaxfit]
	set amax_fitmax [lindex $temp 0]
	lappend amin_fitmin_lst $amin_fitmin
	lappend amax_fitmin_lst $amax_fitmin
	lappend amin_fitmax_lst $amin_fitmax
	lappend amax_fitmax_lst $amax_fitmax
    }
    screate ${basename}_${name}best [lindex $q_lst 0] 1 $bestfit_lst -xy $q_lst
    screate ${basename}_${name}bestamax [lindex $q_lst 0] 1 $amax_bestfit_lst -xy $q_lst
    screate ${basename}_${name}bestamin [lindex $q_lst 0] 1 $amin_bestfit_lst -xy $q_lst

    screate ${basename}_${name}mean [lindex $q_lst 0] 1 $meanfit_lst -xy $q_lst
    screate ${basename}_${name}max [lindex $q_lst 0] 1 $maxfit_lst -xy $q_lst
    screate ${basename}_${name}maxamax [lindex $q_lst 0] 1 $amax_fitmax_lst -xy $q_lst
    screate ${basename}_${name}maxamin [lindex $q_lst 0] 1 $amin_fitmax_lst -xy $q_lst

    screate ${basename}_${name}min [lindex $q_lst 0] 1 $minfit_lst -xy $q_lst
    screate ${basename}_${name}minamax [lindex $q_lst 0] 1 $amax_fitmin_lst -xy $q_lst
    screate ${basename}_${name}minamin [lindex $q_lst 0] 1 $amin_fitmin_lst -xy $q_lst

    if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	screate ${basename}_${name}pref [lindex $q_lst 0] 1 $preffit_lst -xy $q_lst
    }

    set state(localfit,$name,q_lst) $q_lst
    set state(localfit,$name,prefamin) $prefamin
    set state(localfit,$name,prefamax) $prefamax

    return
}


<font color="#208020"># pf::lfDisp --</font>
<font color="#208020"># usage : pf::lfDisp pfId str</font>
<font color="#208020">#</font>
<font color="#208020">#   Display the result of the &#34;localfit&#34; command.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId - The pf id.</font>
<font color="#208020">#   name - h, tau or D.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::lfDisp_3763">proc <a href="partFcts.tcl-annot.html#pf::lfDisp">pf::lfDisp</a></a></strong><a name="pf::lfDisp"></a> {pfid name} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-localfitDone $name
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set prefamin $state(localfit,$name,prefamin)
    set prefamax $state(localfit,$name,prefamax)

    set basename $state(baseSigName)

    set completeLst {}
    if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	set sigLst {}
	foreach val {best pref mean max min} {
	    set sigLst [lappend sigLst ${basename}_${name}$val]
	}
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst2 {}
	foreach val {bestamax bestamin maxamax maxamin minamax minamin} {
	    set sigLst2 [lappend sigLst2 ${basename}_${name}$val]
	}
	set completeLst [lappend completeLst ${sigLst2}]
	set code [catch {mdisp 1 2 ${completeLst}} result]
	if {$code != 0} {
	    error $result $result
	}
	${result}gr0000 setColorsByList {red violet cyan green blue}
	set itemList {}
	foreach value {best pref mean max min} {
	    set itemList [lappend itemlist [list %c $value]]
	}
	eval ${result}gr0000 setLabelsItemsByList $itemList
	${result}gr0000 set_label {black &#34;fit, &#34;} allSigLabel
    } else {
	set sigLst {}
	foreach val {best mean max min} {
	    set sigLst [lappend sigLst ${basename}_${name}$val]
	}
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst2 {}
	foreach val {bestamax bestamin maxamax maxamin minamax minamin} {
	    set sigLst2 [lappend sigLst2 ${basename}_${name}$val]
	}
	set completeLst [lappend completeLst ${sigLst2}]
	set code [catch {mdisp 1 2 ${completeLst}} result]
	if {$code != 0} {
	    error $result $result
	}
	${result}gr0000 setColorsByList {red cyan green blue}
	set itemList {}
	foreach value {best mean max min} {
	    set itemList [lappend itemlist [list %c $value]]
	}
	eval ${result}gr0000 setLabelsItemsByList $itemList
	${result}gr0000 set_label {black &#34;fit, &#34;} allSigLabel
    }
    ${result}gr0001 setColorsByList {red red green green blue blue}
    set itemList1 {}
    foreach value {best .. max .. min ..} {
	set itemList1 [lappend itemlist1 [list %c $value]]
    }
    eval ${result}gr0001 setLabelsItemsByList $itemList1
    ${result}gr0001 set_label {black &#34;Range for, &#34;} allSigLabel

    ${result} switch_allgraph_flag
    ${result} gr set_disp_mode all
    ${result} gr init_disp
    if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	${result} setLabel &#34;Local fit for ${name}(q)  -  pref ($prefamin - $prefamax)&#34;
    } else {
	${result} setLabel &#34;Local fit for ${name}(q)&#34;
    }

    return $result
}


<font color="#208020"># pf::localslope --</font>
<font color="#208020"># usage : pf::localslope str str real</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the local linear regression of the partition functions ``name''</font>
<font color="#208020"># of order q. Take windows of size 1/2, 1, 1.5 and 2 dyades.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId - The pf id.</font>
<font color="#208020">#   str  - Name of the partition functions (i.e. tau, h or D).</font>
<font color="#208020">#   real - The considered q value.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The list of the name of the 4 created signals.</font>

<strong><a name="pf::localslope_3866">proc <a href="partFcts.tcl-annot.html#pf::localslope">pf::localslope</a></a></strong><a name="pf::localslope"></a> {pfid name q} { 
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-thdDone
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set basename $state(baseSigName)

    set q_str [<a name="get_q_str(60)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
    set num [ssize ${basename}_${name}$q_str]
    set x0 [sgetx0 ${basename}_${name}$q_str]
    set dx [sgetdx ${basename}_${name}$q_str]
    set WindLst {5 10 15 20}

    set sigLst {}
    foreach wind $WindLst {
	catch {unset fit_lst}
	catch {unset x_lst}
	
	set numb [expr $num-$wind]
	for {set i 0} {$i &lt;= $numb} {incr i} {
	    set amin [expr $x0+$dx*$i]
	    set amax [expr $amin+$wind*$dx]
	    set posx [expr ($amin+$amax)/2.0]
	    set fit [sfit ${basename}_${name}$q_str $amin $amax]
	    set a [lindex $fit 0]
	    if {![string compare $a nan]} {
		set a 0
	    }
	    lappend fit_lst $a
	    lappend x_lst $posx
	}
	screate ${basename}_${name}_wind${wind}_$q_str [lindex $x_lst 0] $dx $fit_lst 
	set sigLst [lappend sigLst ${basename}_${name}_wind${wind}_$q_str]
    }

    lappend state(localslope,$name,q_lst) $q

    return $sigLst
}


<font color="#208020"># pf::lsDisp --</font>
<font color="#208020"># usage : pf::lsDisp pfId str real</font>
<font color="#208020">#</font>
<font color="#208020">#   Display the result of the &#34;localslope&#34; command.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId - The pf id.</font>
<font color="#208020">#   name - h, tau or D.</font>
<font color="#208020">#   real - The considered q value.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::lsDisp_3932">proc <a href="partFcts.tcl-annot.html#pf::lsDisp">pf::lsDisp</a></a></strong><a name="pf::lsDisp"></a> {pfid name q} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-localslopeDone $name $q
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set basename $state(baseSigName)
    set q_str [<a name="get_q_str(61)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
    set dx [sgetdx ${basename}_${name}$q_str]

    set WindLst {5 10 15 20}

    set sigLst {}
    foreach wind $WindLst {
	set sigLst [lappend sigLst ${basename}_${name}_wind${wind}_$q_str]
    }

    set completelst {}
    set completeLst [lappend completeLst ${sigLst}]
    set code [catch {mdisp 1 1 ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }
    ${result}gr0000 setColorsByList {red cyan green blue}
    set itemList {}
    foreach value $WindLst {
	set value [format &#34;%.5g&#34; [expr $value*$dx]]
	set itemList [lappend itemlist [list %c $value]]
    }
    eval ${result}gr0000 setLabelsItemsByList $itemList
    ${result}gr0000 set_label {black &#34;Window size, &#34;} allSigLabel

    ${result} switch_allgraph_flag
    ${result} gr set_disp_mode all
    ${result} gr init_disp
    ${result} setLabel &#34;Local slope for ${name}($q)&#34;

    return $result
}


<font color="#208020"># pf::allloc --</font>
<font color="#208020">#</font>
<font color="#208020">#   This command is unstable. So if you want to use it, take a look to its</font>
<font color="#208020"># definition.</font>

<strong><a name="pf::allloc_3989">proc <a href="partFcts.tcl-annot.html#pf::allloc">pf::allloc</a></a></strong><a name="pf::allloc"></a> {pfid name qliste} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set complete_Lst {}
    foreach qq $qliste {
        set sig_Lst {}
        set list [<a name="localslope(1)"><a href="./hpcal_proc.tcl.html#localslope_1908">localslope</a></a> $pfid $name $qq]
        foreach name2 $list {
            set sig_Lst [lappend sig_Lst $name2] 
        }
        set complete_Lst [lappend complete_Lst $sig_Lst]        
    }
    set code [catch {mdisp 3 3 ${complete_Lst}} result]
    if {$code != 0} {
        error $result $result
    }
    ${result} setColorsByList {red cyan green blue}
    set itemList {}    
    foreach value {0.5 1.0 1.5 2.0} {
        set itemList [lappend itemlist [list %c $value]]
    }
    eval ${result} setLabelsItemsByList $itemList
    set r 0
    set l 0
    foreach qq $qliste {
        set newL [format &#34;%.2d&#34; $l]
        set newR [format &#34;%.2d&#34; $r]
        ${result}gr${newR}${newL} set_label [list black &#34;$name q=$qq W. size, &#34;] allSigLabel
        incr l
        if {$l == 3} {
            set l 0
            incr r
        }
    }
    ${result} switch_allgraph_flag
    ${result} gr set_disp_mode all
    ${result} gr init_disp
    ${result} setLabel &#34;Local slope for ${name}(q)&#34;

    return $result
}


<font color="#208020"># pf::Dh --</font>
<font color="#208020"># usage : pf::Dh pfId [real real]</font>
<font color="#208020">#</font>
<font color="#208020">#  Compute D(h) with D(q) and h(q).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId     - The pf id.</font>
<font color="#208020">#   [2 real] - q min and q max.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::Dh_4049">proc <a href="partFcts.tcl-annot.html#pf::Dh">pf::Dh</a></a></strong><a name="pf::Dh"></a> {pfid {qMin &#34;&#34;} {qMax &#34;&#34;}} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist \
		-thdDone \
		-thdFitDone
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set name $state(baseSigName)

    set hq ${name}_hq
    set Dq ${name}_Dq
    <font color="#208020">#set hqlst [sgetlst $hq ]</font>
    set hqlst {}
    set tmp1 [sgetlst $hq -x]
    set tmp2 [sgetlst $hq -y]
    foreach data1 $tmp1 data2 $tmp2 {
	lappend hqlst [list $data1 $data2]
    }
    <font color="#208020">#set Dqlst [sgetlst $Dq ]</font>
    set Dqlst {}
    set tmp1 [sgetlst $Dq -x]
    set tmp2 [sgetlst $Dq -y]
    foreach data1 $tmp1 data2 $tmp2 {
	lappend Dqlst [list $data1 $data2]
    }
    set hlst &#34;&#34;
    set Dlst &#34;&#34;
    set theqlst &#34;&#34;
    foreach q $state(q_lst) {
	if {$q &gt;= $qMin &amp; $q &lt;= $qMax} {
	    lappend theqlst $q
	}
    }

    <font color="#208020">#echo theqlst $theqlst</font>

    <font color="#208020"># on peut remplacer dans la ligne suivante theqlst par state(q_lst)</font>
    <font color="#208020">#puts &#34;$theqlst&#34;</font>
    foreach hq $hqlst Dq $Dqlst q $theqlst {
	if {$qMin == &#34;&#34; || ($q &gt;= $qMin &amp;&amp; $q &lt;= $qMax)} {
	    lappend hlst [lindex $hq 1]
	    lappend Dlst [lindex $Dq 1]
	}
    }

    <a name="echo(5)"><a href="./tkcon.tcl.html#echo_3895">echo</a></a> dh $Dlst hlst $hlst

    screate ${name}_Dh 0 1 $Dlst -xy $hlst

    return
}


<font color="#208020"># pf::Dh_tsallis --</font>
<font color="#208020"># usage : pf::Dh pfId real [real real]</font>
<font color="#208020">#</font>
<font color="#208020">#  Compute Dtsa(htsa) with Dtsa(q) and htsa(q) for a given value of</font>
<font color="#208020"># Tsallis parameter.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId     - The pf id.</font>
<font color="#208020">#   real     - Tsallis parameter (must be one of qtsa_lst defined in</font>
<font color="#208020">#              your file parameters.tcl)</font>
<font color="#208020">#   [2 real] - q min and q max.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::Dh_tsallis_4128">proc <a href="partFcts.tcl-annot.html#pf::Dh_tsallis">pf::Dh_tsallis</a></a></strong><a name="pf::Dh_tsallis"></a> {pfid qtsa {qMin &#34;&#34;} {qMax &#34;&#34;}} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set code [catch {
	StateCheck $pfid \
		-dataExist
    } result]
    if {$code == 1} {
	return -code error $result
    }

    set name $state(baseSigName)
    set qtsa_str [<a name="get_q_str(62)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]

    set hqtsa ${name}_hq_${qtsa_str}
    set Dqtsa ${name}_Dq_${qtsa_str}
    set hqtsalst [sgetlst $hqtsa]
    <font color="#208020">#echo $hqtsalst</font>
    set Dqtsalst [sgetlst $Dqtsa]
    <font color="#208020">#echo $Dqtsalst</font>
    set htsalst &#34;&#34;
    set Dtsalst &#34;&#34;
    set theqlst &#34;&#34;
    foreach q $state(q_lst) {
	if {$q &gt;= $qMin &amp; $q &lt;= $qMax} {
	    lappend theqlst $q
	}
    }
    <font color="#208020"># on peut remplacer dans la ligne suivante theqlst par state(q_lst)</font>
    foreach hqtsa $hqtsalst Dqtsa $Dqtsalst q $theqlst {
	if {$qMin == &#34;&#34; || ($q &gt;= $qMin &amp;&amp; $q &lt;= $qMax)} {
	    lappend htsalst [lindex $hqtsa 1]
	    lappend Dtsalst [lindex $Dqtsa 1]
	}
    }
    <font color="#208020">#echo $htsalst</font>
    <font color="#208020">#echo $Dtsalst</font>
    screate ${name}_Dh_${qtsa_str} 0 1 $Dtsalst -xy $htsalst

    return
}


<font color="#208020"># pf::thdDisp --</font>
<font color="#208020"># usage : pf::thdDisp pfId [list]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display tau(q), h(q), D(q) and D(h).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [list] - one or more of the following : tq, hq, Dq, Dh. Default is all.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -tsallis real : Display logZtsa(q), htsa(q), Dtsa(q) and Dtsa(htsa)</font>
<font color="#208020">#                   for some value of tsallis parameter.</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::thdDisp_4190">proc <a href="partFcts.tcl-annot.html#pf::thdDisp">pf::thdDisp</a></a></strong><a name="pf::thdDisp"></a> {pfid args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set isTsallis no
    <font color="#208020"># Arguments analysis</font>
    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -tsallis {
		set qtsa [lindex $args 1]
		set args [lreplace $args 0 1]
		set isTsallis yes
		set qtsa_str [<a name="get_q_str(63)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    set base $state(baseSigName)

    if {$isTsallis == &#34;yes&#34;} {
	set completeLst [list ${base}_tq_${qtsa_str} ${base}_hq_${qtsa_str} ${base}_Dq_${qtsa_str} ${base}_Dh_${qtsa_str}]
    } else {
	set completeLst [list ${base}_tq ${base}_hq ${base}_Dq ${base}_Dh]
    }

    set code [catch {mdisp 2 2 ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }

    ${result} gr set_disp_mode one
    if {$state(dimension) == &#34;2D&#34;} {
	set source &#34;image(s)&#34;
    } else {
	set source &#34;signal(s)&#34;
    }
    if {$isTsallis == &#34;yes&#34;} {
	${result} setLabel &#34;Tsallis : qtsallis = $qtsa; $state(comments)\n($state(a_min), $state(n_octave), \
		$state(n_voice)) ; $state(n_study) $source\n$state(study_method)&#34; 3
	
	${result}gr0000 set_label {black &#34;logZtsa(q)&#34;}
	${result}gr0100 set_label {black &#34;Dtsa(q)&#34;}
	${result}gr0001 set_label {black &#34;htsa(q)&#34;}
	${result}gr0101 set_label {black &#34;Dtsa(h)&#34;}
    } else {
	${result} setLabel &#34;$state(comments)\n($state(a_min), $state(n_octave), \
		$state(n_voice)) ; $state(n_study) $source\n$state(study_method)&#34; 3
	
	${result}gr0000 set_label {black &#34;tau(q)&#34;}
	${result}gr0100 set_label {black &#34;D(q)&#34;}
	${result}gr0001 set_label {black &#34;h(q)&#34;}
	${result}gr0101 set_label {black &#34;D(h)&#34;}
    }
    ${result} gr init_disp
    eval ${result} print dh.eps
    
    return $result
}


<font color="#208020"># pf::thdDisp2 --</font>
<font color="#208020"># usage : pf::thdDisp2 pfId1 pfId2 [list]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display tau(q), h(q), D(q) and D(h) for 2 pf's on the same graph's.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [list] - one or more of the following : tq, hq, Dq, Dh. Default is all.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -tsallis real : Display logZtsa(q), htsa(q), Dtsa(q) and Dtsa(htsa)</font>
<font color="#208020">#                   for some value of tsallis parameter.</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::thdDisp2_4271">proc <a href="partFcts.tcl-annot.html#pf::thdDisp2">pf::thdDisp2</a></a></strong><a name="pf::thdDisp2"></a> {pfid1 pfid2 args} {
    set pfid1 [CheckPfid $pfid1]
    if {$pfid1 == 0} {
	return -code error &#34;wrong pf id1&#34;
    }
    variable $pfid1
    upvar 0 $pfid1 state1
    
    set pfid2 [CheckPfid $pfid2]
    if {$pfid2 == 0} {
	return -code error &#34;wrong pf id2&#34;
    }
    variable $pfid2
    upvar 0 $pfid2 state2
    
    set isTsallis no
    <font color="#208020"># Arguments analysis</font>
    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }
    
    set base1 $state1(baseSigName)
    set base2 $state2(baseSigName)
    
    set completeLst {}
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_tq]
    set sigLst [lappend sigLst ${base2}_tq]
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_hq]
    set sigLst [lappend sigLst ${base2}_hq]
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_Dq]
    set sigLst [lappend sigLst ${base2}_Dq]
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_Dh]
    set sigLst [lappend sigLst ${base2}_Dh]
    set completeLst [lappend completeLst ${sigLst}]
    <font color="#208020">#set completeLst [list [list ${base1}_tq ${base2}_tq] ${base1}_hq ${base1}_Dq ${base1}_Dh]</font>
    
    set code [catch {mdisp 2 2 ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }

    ${result} switch_allgraph_flag
    ${result} gr set_disp_mode all
    if {$state1(dimension) == &#34;2D&#34;} {
	set source &#34;image(s)&#34;
    } else {
	set source &#34;signal(s)&#34;
    }
    
    ${result} setLabel &#34;$state1(comments)\n($state1(a_min), $state1(n_octave), \
	    $state1(n_voice)) ; $state1(n_study) $source\n$state1(study_method)&#34; 3
    
    $result setColorsByList {red blue yellow brown slateblue}
	
    ${result}gr0000 set_label {black &#34;tau(q)&#34;}
    ${result}gr0100 set_label {black &#34;D(q)&#34;}
    ${result}gr0001 set_label {black &#34;h(q)&#34;}
    ${result}gr0101 set_label {black &#34;D(h)&#34;}
    
    ${result} gr init_disp
    eval ${result} print dh.eps
    
    return $result
}

<font color="#208020"># pf::thdDisp3 --</font>
<font color="#208020"># usage : pf::thdDisp3 pfId1 pfId2 pfId3 [list]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display tau(q), h(q), D(q) and D(h) for 3 pf's on the same graph's.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [list] - one or more of the following : tq, hq, Dq, Dh. Default is all.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -tsallis real : Display logZtsa(q), htsa(q), Dtsa(q) and Dtsa(htsa)</font>
<font color="#208020">#                   for some value of tsallis parameter.</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::thdDisp3_4361">proc <a href="partFcts.tcl-annot.html#pf::thdDisp3">pf::thdDisp3</a></a></strong><a name="pf::thdDisp3"></a> {pfid1 pfid2 pfid3 args} {
    set pfid1 [CheckPfid $pfid1]
    if {$pfid1 == 0} {
	return -code error &#34;wrong pf id1&#34;
    }
    variable $pfid1
    upvar 0 $pfid1 state1
    
    set pfid2 [CheckPfid $pfid2]
    if {$pfid2 == 0} {
	return -code error &#34;wrong pf id2&#34;
    }
    variable $pfid2
    upvar 0 $pfid2 state2
    
    set pfid3 [CheckPfid $pfid3]
    if {$pfid3 == 0} {
	return -code error &#34;wrong pf id3&#34;
    }
    variable $pfid3
    upvar 0 $pfid3 state3
    
    set isTsallis no
    <font color="#208020"># Arguments analysis</font>
    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }
    
    set base1 $state1(baseSigName)
    set base2 $state2(baseSigName)
    set base3 $state3(baseSigName)
    
    set completeLst {}
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_tq]
    set sigLst [lappend sigLst ${base2}_tq]
    set sigLst [lappend sigLst ${base3}_tq]
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_hq]
    set sigLst [lappend sigLst ${base2}_hq]
    set sigLst [lappend sigLst ${base3}_hq]
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_Dq]
    set sigLst [lappend sigLst ${base2}_Dq]
    set sigLst [lappend sigLst ${base3}_Dq]
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_Dh]
    set sigLst [lappend sigLst ${base2}_Dh]
    set sigLst [lappend sigLst ${base3}_Dh]
    set completeLst [lappend completeLst ${sigLst}]
    <font color="#208020">#set completeLst [list [list ${base1}_tq ${base2}_tq] ${base1}_hq ${base1}_Dq ${base1}_Dh]</font>
    
    set code [catch {mdisp 2 2 ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }

    ${result} switch_allgraph_flag
    ${result} gr set_disp_mode all
    if {$state1(dimension) == &#34;2D&#34;} {
	set source &#34;image(s)&#34;
    } else {
	set source &#34;signal(s)&#34;
    }
    
    ${result} setLabel &#34;$state1(comments)\n($state1(a_min), $state1(n_octave), \
	    $state1(n_voice)) ; $state1(n_study) $source\n$state1(study_method)&#34; 3
    
    $result setColorsByList {red blue black brown slateblue}
	
    ${result}gr0000 set_label {black &#34;tau(q)&#34;}
    ${result}gr0100 set_label {black &#34;D(q)&#34;}
    ${result}gr0001 set_label {black &#34;h(q)&#34;}
    ${result}gr0101 set_label {black &#34;D(h)&#34;}
    
    ${result} gr init_disp
    eval ${result} print dh.eps
    
    return $result
}

<font color="#208020"># pf::thdDisp4 --</font>
<font color="#208020"># usage : pf::thdDisp4 pfId1 pfId2 pfId3 pfId4 [list]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display tau(q), h(q), D(q) and D(h) for 4 pf's on the same graph's.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [list] - one or more of the following : tq, hq, Dq, Dh. Default is all.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -tsallis real : Display logZtsa(q), htsa(q), Dtsa(q) and Dtsa(htsa)</font>
<font color="#208020">#                   for some value of tsallis parameter.</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::thdDisp4_4463">proc <a href="partFcts.tcl-annot.html#pf::thdDisp4">pf::thdDisp4</a></a></strong><a name="pf::thdDisp4"></a> {pfid1 pfid2 pfid3 pfid4 args} {
    set pfid1 [CheckPfid $pfid1]
    if {$pfid1 == 0} {
	return -code error &#34;wrong pf id1&#34;
    }
    variable $pfid1
    upvar 0 $pfid1 state1
    
    set pfid2 [CheckPfid $pfid2]
    if {$pfid2 == 0} {
	return -code error &#34;wrong pf id2&#34;
    }
    variable $pfid2
    upvar 0 $pfid2 state2
    
    set pfid3 [CheckPfid $pfid3]
    if {$pfid3 == 0} {
	return -code error &#34;wrong pf id3&#34;
    }
    variable $pfid3
    upvar 0 $pfid3 state3
    
    set pfid4 [CheckPfid $pfid4]
    if {$pfid4 == 0} {
	return -code error &#34;wrong pf id4&#34;
    }
    variable $pfid4
    upvar 0 $pfid4 state4
    
    set isTsallis no
    <font color="#208020"># Arguments analysis</font>
    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }
    
    set base1 $state1(baseSigName)
    set base2 $state2(baseSigName)
    set base3 $state3(baseSigName)
    set base4 $state4(baseSigName)
    
    set completeLst {}
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_tq]
    set sigLst [lappend sigLst ${base2}_tq]
    set sigLst [lappend sigLst ${base3}_tq]
    set sigLst [lappend sigLst ${base4}_tq]
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_hq]
    set sigLst [lappend sigLst ${base2}_hq]
    set sigLst [lappend sigLst ${base3}_hq]
    set sigLst [lappend sigLst ${base4}_hq]
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_Dq]
    set sigLst [lappend sigLst ${base2}_Dq]
    set sigLst [lappend sigLst ${base3}_Dq]
    set sigLst [lappend sigLst ${base4}_Dq]
    set completeLst [lappend completeLst ${sigLst}]
    set sigLst {}
    set sigLst [lappend sigLst ${base1}_Dh]
    set sigLst [lappend sigLst ${base2}_Dh]
    set sigLst [lappend sigLst ${base3}_Dh]
    set sigLst [lappend sigLst ${base4}_Dh]
    set completeLst [lappend completeLst ${sigLst}]
    <font color="#208020">#set completeLst [list [list ${base1}_tq ${base2}_tq] ${base1}_hq ${base1}_Dq ${base1}_Dh]</font>
    
    set code [catch {mdisp 2 2 ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }

    ${result} switch_allgraph_flag
    ${result} gr set_disp_mode all
    if {$state1(dimension) == &#34;2D&#34;} {
	set source &#34;image(s)&#34;
    } else {
	set source &#34;signal(s)&#34;
    }
    
    ${result} setLabel &#34;$state1(comments)\n($state1(a_min), $state1(n_octave), \
	    $state1(n_voice)) ; $state1(n_study) $source\n$state1(study_method)&#34; 3

    <font color="#208020">#set english_red &#34;0.8300 0.2400 0.1000&#34;</font>

    $result setColorsByList {red blue magenta slateblue}
	
    ${result}gr0000 set_label {black &#34;tau(q)&#34;}
    ${result}gr0100 set_label {black &#34;D(q)&#34;}
    ${result}gr0001 set_label {black &#34;h(q)&#34;}
    ${result}gr0101 set_label {black &#34;D(h)&#34;}
    
    ${result} gr init_disp
    eval ${result} print dh.eps
    
    return $result
}


<font color="#208020"># pf::taudDisp --</font>
<font color="#208020"># usage : pf::taudDisp pfId [list]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display tau(q) and D(h).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [list] - one or more of the following : tq and Dh. Default is all.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -tsallis real : Display logZtsa(q), htsa(q), Dtsa(q) and Dtsa(htsa)</font>
<font color="#208020">#                   for some value of tsallis parameter.</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="pf::taudDisp_4580">proc <a href="partFcts.tcl-annot.html#pf::taudDisp">pf::taudDisp</a></a></strong><a name="pf::taudDisp"></a> {pfid args} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set isTsallis no
    <font color="#208020"># Arguments analysis</font>
    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -tsallis {
		set qtsa [lindex $args 1]
		set args [lreplace $args 0 1]
		set isTsallis yes
		set qtsa_str [<a name="get_q_str(64)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $qtsa]
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    set base $state(baseSigName)

    if {$isTsallis == &#34;yes&#34;} {
	set completeLst [list ${base}_tq_${qtsa_str} ${base}_Dh_${qtsa_str}]
    } else {
	set completeLst [list ${base}_tq ${base}_Dh]
    }

    set code [catch {mdisp 1 2 ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }

    ${result} gr set_disp_mode one
    if {$state(dimension) == &#34;2D&#34;} {
	set source &#34;image(s)&#34;
    } else {
	set source &#34;signal(s)&#34;
    }
    if {$isTsallis == &#34;yes&#34;} {
	${result} setLabel &#34;Tsallis : qtsallis = $qtsa; $state(comments)\n($state(a_min), $state(n_octave), \
		$state(n_voice)) ; $state(n_study) $source\n$state(study_method)&#34; 3
	
	${result}gr0000 set_label2 {black &#34;logZtsa(q)&#34;}
	${result}gr0001 set_label2 {black &#34;Dtsa(h)&#34;}
    } else {
	${result} setLabel &#34;&#34;
	
	${result}gr0000 set_label {black &#34;tau(q)&#34;}
	${result}gr0001 set_label {black &#34;D(h)&#34;}
	
    }
    ${result} gr init_disp
    eval ${result} print dh.eps

    return $result
}


<font color="#208020"># pf::GetBaseName - PRIVATE</font>
<font color="#208020"># usage : pf::GetBaseName pfId</font>
<font color="#208020">#</font>
<font color="#208020">#   Get the signals base name of a pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId - the pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The base name.</font>

<strong><a name="pf::GetBaseName_4654">proc <a href="partFcts.tcl-annot.html#pf::GetBaseName">pf::GetBaseName</a></a></strong><a name="pf::GetBaseName"></a> {pfid} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    return $state(baseSigName)
}


<font color="#208020"># pf::getParam --</font>
<font color="#208020"># usage : pf::getParam pfId str</font>
<font color="#208020">#</font>
<font color="#208020">#   Get the value of a parameter of a pf.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - the pf id.</font>
<font color="#208020">#   string - the parameter name.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The value.</font>

<strong><a name="pf::getParam_4678">proc <a href="partFcts.tcl-annot.html#pf::getParam">pf::getParam</a></a></strong><a name="pf::getParam"></a> {pfid pName} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    if {[info exists state($pName)] != 1} {
	return -code error &#34;wrong parameter name&#34;
    }

    return $state($pName)
}


<font color="#208020"># pf::setcomments --</font>
<font color="#208020"># usage : pf::setcomments pfId str</font>
<font color="#208020">#</font>
<font color="#208020">#   Get the value of a parameter of a pf.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - the pf id.</font>
<font color="#208020">#   string - comments (list)</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The value.</font>

<strong><a name="pf::setcomments_4706">proc <a href="partFcts.tcl-annot.html#pf::setcomments">pf::setcomments</a></a></strong><a name="pf::setcomments"></a> {pfid comments} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set state(comments)	$comments
    return
}


<font color="#208020"># pf::tauNorm --</font>
<font color="#208020"># usage : pf::tauNorm pfId</font>
<font color="#208020">#</font>
<font color="#208020">#   Add a constant to tau(q) to obtain tau(0) = -2.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   pfId   - the pf id.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The value of the constant.</font>

<strong><a name="pf::tauNorm_4730">proc <a href="partFcts.tcl-annot.html#pf::tauNorm">pf::tauNorm</a></a></strong><a name="pf::tauNorm"></a> {pfid tauName} {
    set pfid [CheckPfid $pfid]
    if {$pfid == 0} {
	return -code error &#34;wrong pf id&#34;
    }
    variable $pfid
    upvar 0 $pfid state

    set tauSig [<a name="pf(1)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> GetBaseName $pfid]_$tauName

    sigloop $tauSig {
	set tau_0 [expr { $y } ]
	if {$x == 0} {
	    break
	}
	if {$x &gt; 0} {
	    return -code error &#34;no value for tau(0)&#34;
	}
    }

    set value [expr { -2 - $tau_0 }]

    s2fs $tauSig $tauSig x y+$value

    return $value
}


</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
